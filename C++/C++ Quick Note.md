---
tags:
  - cpp
---

**new/delete**
동적 할당 시에 new를 사용하고, 할당을 해제할 때 delete를 사용한다.
단일 객체는 delete, 배열은 delete\[\]사용
또한 동적 메모리 할당 시에는 포인터를 사용한다.

ChatGPT에게 배운 이후 특정 섹션에 대한 추가적인 공부는 cppreference를 참조하자

using namespace std 는 가급적 사용하지 말라고 합니다
# Pointers
```cpp
int arr[10];
int *parr = arr;

int i;
int *pi = &i;
```
포인터는 특정 변수의 주소를 저장해서, 그 주소를 통해 메모리에 접근할 수 있도록 한다.
`&` 연산자는 변수의 메모리 주소를 반환한다. 예를 들어, `&i`는 변수 `i`의 메모리 주소를 나타낸다.
`*` 연산자는 역참조(dereferencing) 연산자라고 하며, 포인터가 가리키는 메모리 주소에 저장된 값에 접근할 때 사용된다.
`&i`의 의미:
`&i`는 변수 `i`의 메모리 주소를 나타낸다. 포인터는 변수의 주소를 저장하는 것이므로, 
포인터를 초기화할 때는 변수의 메모리 주소를 사용해야 한다.
```cpp
int i = 10; // 정수형 변수 i 선언 및 초기화 
int* pi = &i; // 변수 i의 메모리 주소를 포인터 pi에 저장
```
위 코드에서 `&i`는 변수 `i`의 주소를 포인터 `pi`에 저장하는 역할을 한다. 이 주소를 통해 `pi`는 `i`를 가리키게 된다.

포인터도 타입이 존재한다.
하지만 일반 변수와 다르게 타입이 달라진다고 포인터의 크기가 변하는 것은 아니다.
포인터의 타입은 그 포인터가 가리키는 메모리를 어떻게 다룰지에 대한 정보를
컴파일러에게 알려주는 규칙이다.

# Smart pointers
new/delete 대신 "스마트 포인터"를 사용 가능. 
스마트 포인터는 C++11이후 권장되는 방식으로, 메모리 누수 방지, 메모리 관리 자동화 등의 다양한 이점이 있다.
std::unique_ptr를 사용해 배열의 메모리를 안전하게 관리할 수 있다.
예시) `std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);`
std::unique_ptr<int\[\]>는 배열을 가리키는 스마트 포인터이다. \[\]를 사용하여 배열을 동적 할당할 수 있도록 타입을 지정해야 한다.
std::make_unique<int\[\]>()를 사용해 크기가 10인 정수 배열을 동적 할당한다.
배열을 사용한 후에는 메모리를 명시적으로 해제할 필요 없이, 프로그램이 끝나면 스마트 포인터가 자동으로 메모리를 해제한다.

# const &
const 는 복사가 일어난다. 하지만 const & 는 복사 없이 안전하게 원본 데이터를 수정하지 못하게 한다.

# 원본 변수 수정하지 않기
int와 같은 기본 타입의 경우에는 call by value
class, struct와 같은 사용자 정의 타입의 경우 call by const reference
로 사용하는 것이 좋다.

# Casting
C style 캐스팅은 강력하지만 위험하다.
왜냐하면 코드에 캐스팅의 의도를 나타낼 수 없다.
그래서 위험해 보이는 캐스팅이 의도인지 실수인지 알 수 없다.
따라서 안전성이 부족하므로 C 스타일의 () 캐스팅은 절대 사용 금지

이 문제를 해결하기 위해 C++에서는 목적에 따라 4가지의 명시적인 캐스팅 연산자를 도입하였다.
1. static_cast
2. reinterpret_cast
3. const_cast
4. dynamic_cast
먼저 static_cast에 대해 알아보자.
가장 기본 캐스팅으로, 안전한 코드를 위해서는 이 캐스팅만 사용하는 것이 권장된다.
논리적으로 맞고 위험하지 않은 경우만 허용한다.
기본 타입의 값 캐스팅, `void*` 에서 다른 타입의 포인터로 캐스팅, 상속관계의 캐스팅 등
반드시 연관성이 있어야 한다.

reinterpret_cast 는 이름 그대로 포인터(또는 정수)가 가리키는 메모리의 비트 패턴을 단순히 다른 타입으로 재해석하라고 지시한다. 타입 시스템을 완전히 무시하는, C-style 캐스팅만큼이나 위험한 도구다.
하지만 C style 캐스팅과 달리 명확한 의도를 가지고 사용했음을 코드에 보여준다.
reinterpret_cast 는 2가지 용도에서만 사용 가능하다.
1. 서로 다른 타입의 주소(reference) 변환
2. 정수 <=> 주소 사이의 변환

const_cast 는 **동일타입** 변수의 "상수성을 제거" 하는 캐스팅이다.

dynamic_cast 추가 예정

결론적으로, C++ 코드에서 캐스팅이 필요하면
C 스타일 캐스팅은 금지
기본적으로 static_cast 로 진행
혹시 에러가 발생하면, reinterpret_cast 와 const_cast 중에서 용도에 맞게 선택
그래도 에러가 발생하면 코드 자체가 논리적으로 잘못된 것

# 초기화 리스트
멤버 초기화 리스트에서 멤버 변수들의 초기화 순서는 리스트에 작성된 순서가 아니라
클래스에 선언된 순서에 따라 결정된다.

# 객체지향 S/W 설계의 5개 원칙
SRP OCP LSP ISP DIP >>> SOLID 원칙