# [백준] 1475: 방 번호

## 1. 문제 정보
- **태그**: #구현 #수학 #문자열 #review/30-day/260225 
- **난이도**: Silver V
- **날짜**: 2026-01-15

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 0~9 한 세트인 플라스틱 숫자를 이용해 방 번호를 만들 때 필요한 최소 세트 수 구하기.
- **핵심 발상**: 
    1. 숫자 **6과 9는 서로 뒤집어서 쓸 수 있다**는 점이 포인트.
    2. 따라서 6과 9는 같은 숫자로 취급하여 개수를 합친 뒤, 2로 나누어 필요한 세트 수를 계산함.
    3. 나머지 숫자들은 단순히 가장 많이 필요한 개수가 곧 세트 수가 됨.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **빈도수 배열 (Frequency Array)**: `arr[10]`을 만들어 각 숫자가 몇 번 등장했는지 카운팅.
- **데이터 정규화**: 입력받는 즉시 `9`를 `6`으로 변환하여 저장함으로써 로직을 단순화함.
- **시간 복잡도**: $O(N)$ 
    - 방 번호 $S$의 길이만큼 한 번 순회하므로 매우 효율적임.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **올림 처리 (Ceiling)**: 6과 9를 합친 개수가 홀수일 때(예: 3개), 2로 나누면 정수 나눗셈 때문에 1이 됨. 실제로는 2세트가 필요하므로 `(count + 1) / 2`로 올림 처리를 해야 함.
- **문자-숫자 변환**: `string`의 요소를 `int` 인덱스로 쓸 때 `s[i] - '0'`을 빼먹지 않도록 주의.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `algorithm` 헤더의 `max_element`를 사용하여 코드가 매우 간결해짐.
    - `ios::sync_with_stdio(0)`로 입출력 성능을 최적화한 점이 좋음.
    - 6과 9 처리를 루프 안에서 조건문으로 처리하고, 계산은 마지막에 한 번만 수행하여 효율적임.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string s;
	cin >> s;
	int arr[10]{};
	for (int i{}; i < s.size(); ++i) {
		int num{ s[i] - '0' };
		if (num == 9) { // 9를 6으로 매핑하여 통합 관리
			num = 6;
		}
		arr[num]++;
	}
	// 6과 9는 한 세트에 2개 포함된 효과이므로 2로 나누되, 홀수 개수를 위해 올림 처리
	arr[6] = (arr[6] + 1) / 2;
	
	// 전체 배열 중 가장 많이 필요한 숫자의 개수가 답
	int result{ *max_element(arr, arr + 10) };
	cout << result;
}
```
# [백준] 3273: 두 수의 합

## 1. 문제 정보
- **태그**: #배열 #투포인터 #해시 #review/7-day/260209
- **난이도**: 실버 3
- **날짜**: 2026-01-16

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: $n$개의 서로 다른 양의 정수 수열에서 $a_i + a_j = x$ ($1 \le i < j \le n$)를 만족하는 쌍의 개수 구하기.
- **핵심 발상**: 
    - 이중 반복문($O(N^2)$)은 시간 초과 발생.
    - 현재 숫자 `A[i]`를 보고 있을 때, **"이전에 `x - A[i]`가 등장했는가?"** 를 배열(Lookup Table)을 통해 $O(1)$에 확인해야 함.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **Frequency Array (Boolean Check)**: 
    - `check` 배열을 사용하여 특정 숫자의 등장 여부를 저장.
    - 정렬이 필요 없는 $O(N)$ 풀이 방식.
- **시간 복잡도**: $O(N)$ 
    - 수열을 한 번만 순회하면서 검사와 기록을 동시에 수행함.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **[핵심 오답] 검사와 갱신(Update)의 순서**:
    - **실수**: `check[A[i]] = true`를 `if`문보다 **먼저** 작성함.
    - **결과**: $x=10, A[i]=5$인 경우, 5를 먼저 기록해버리면 `check[10-5]`가 `true`가 되어 **자기 자신을 짝으로 착각**하게 됨.
    - **해결**: 반드시 **"짝이 있는지 먼저 검사(Check)"** 한 뒤에 **"나를 기록(Update)"** 해야 함. ($i < j$ 조건 만족)
- **인덱스 범위 (Out of Bounds)**:
    - `x - A[i]`가 음수가 될 수 있으므로 `> 0` 조건 필수.
    - $x$의 최댓값이 2,000,000이므로 `check` 배열 크기도 이에 맞춰 넉넉히 잡아야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - 전역 배열 사용으로 스택 오버플로우 방지 및 0 초기화 활용이 좋음.
    - `ios::sync_with_stdio(0)`로 입출력 성능 최적화 완료.
    - **수정 성공**: `check` 갱신 코드를 `if`문 아래로 내려서 자기 자신을 포함하는 논리적 오류를 완벽하게 해결함.

```cpp
#include <iostream>
using namespace std;

// x가 최대 200만이므로 check 배열도 200만까지 커버해야 안전함
int A[100001]{};
bool check[2000001]{}; 

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N{};
	cin >> N;
	for (int i{}; i < N; ++i) {
		cin >> A[i];
	}
	int x{};
	cin >> x;
	int result{};
	
	for (int i{}; i < N; ++i) {
		// 1. 유효 범위 체크 (음수 인덱스 방지)
		// 2. 짝이 되는 수(x - A[i])가 "이전에" 나왔는지 확인
		if (x - A[i] > 0 && check[x - A[i]]) {
			result++;
		}
		
		// 3. 검사가 끝난 후 현재 수를 "기록" (순서 중요!)
		check[A[i]] = true;
	}
	cout << result;
}
```
# [백준] 13300: 방 배정

## 1. 문제 정보
- **태그**: #구현 #수학 #시뮬레이션 #review/30-day/260225 
- **난이도**: 브론즈 II
- **날짜**: 2026-01-15

## 2. 문제 요약 & 핵심 아이디어 💡
- 성별과 학년이 같은 학생끼리, 최대 K명 정원의 방에 배정할 때 필요한 **최소 방의 개수** 구하기.
- **핵심 발상**: 
    1. 학생들을 일일이 방에 넣는다고 생각하기보다, **(성별, 학년)별로 인원수를 먼저 세는 것**이 유리함.
    2. 인원수가 정해지면 `(인원수 + K - 1) / K` 공식을 통해 필요한 방의 개수를 수학적으로 즉시 계산 가능 (혹은 시뮬레이션).

## 3. 알고리즘 & 구현 테크닉 🛠️
- **2차원 배열 활용**: `arr[성별][학년]` 형태로 데이터를 분류하여 저장.
- **시뮬레이션 (작성된 코드 방식)**:
    - 학생을 입력받을 때마다 해당 그룹의 인원수를 늘림.
    - 인원이 `K`명을 초과하면, 이미 꽉 찬 방은 보내고 새로운 방을 하나 더 만들었다고 가정하고 카운트를 초기화(`1`)함.
- **시간 복잡도**: $O(N)$
    - 학생 수 N만큼 반복하며 입력을 처리하므로 효율적임.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **배열 인덱스 범위 (Critical!)**: 
    - 문제에서 학년은 `1`부터 `6`까지 주어짐.
    - 작성한 코드 `int arr[2][6]`은 인덱스 `0~5`까지만 접근 가능함.
    - 만약 6학년(`B=6`)이 입력되면 **`arr[A][6]`에 접근하게 되어 런타임 에러(Out of Bounds)** 가 발생할 위험이 매우 큼. 운 좋게 통과했더라도 반드시 수정해야 함.
- **자료형**: 학생 수 N이 최대 1,000명이므로 `int`로 충분함.

## 5. 내 코드 & 피드백
- **코드 리뷰**:
    - **장점**: 입력과 동시에 로직을 처리하여 반복문을 한 번만 사용한 점이 효율적입니다.
    - **개선점**: 
        1. **배열 크기 수정**: 6학년을 저장하려면 `arr[2][7]`로 선언하거나, 접근 시 `arr[A][B-1]`로 인덱스를 조정해야 합니다.
        2. **수학적 접근**: `if`문 분기 대신, 모든 인원을 먼저 센 뒤 `(count + K - 1) / K` 공식을 쓰면 코드가 더 짧아집니다.

```cpp
#include <iostream>
using namespace std;

// [피드백] 6학년(인덱스 6)까지 접근하려면 크기가 7이어야 안전합니다.
// int arr[2][6]{}; (위험) -> int arr[2][7]{}; (권장)
int arr[2][7]{}; 

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N{};
	int K{};
	cin >> N >> K;
	int A{};
	int B{};
	int count{};
	for (int i{}; i < N; ++i) {
		cin >> A >> B;
		arr[A][B]++;
		if (arr[A][B] == 1) {
			count++;
		}
		else if (arr[A][B] > K) {
			// 방이 꽉 찼으므로, 현재 학생은 새로운 방의 첫 번째 학생이 됨
			arr[A][B] = 1;
			count++;
		}
	}
	cout << count;
}
```
### 💡 [Tip] 수학적 접근: 올림(Ceiling) 공식 활용

기존 코드가 "한 명씩 넣으면서 방이 차면 비우는" **시뮬레이션** 방식이었다면, 이번 코드는 "총인원을 먼저 센 뒤, 필요한 방의 개수를 한 번에 계산하는" **수학적** 방식입니다.

#### 핵심 공식
$$\text{필요한 방의 수} = \left\lceil \frac{\text{학생 수}}{\text{최대 정원 } K} \right\rceil$$
C++ 정수 연산에서는 나눗셈 시 소수점이 버려지므로, 아래와 같은 테크닉으로 **올림(Ceiling)** 효과를 냅니다.
$$\text{rooms} = (N + K - 1) / K$$

#### 개선된 코드
```cpp
#include <iostream>
using namespace std;

// [개선] 6학년(인덱스 6)까지 안전하게 접근하기 위해 크기를 7로 설정
// 전역 변수는 자동으로 0으로 초기화됩니다.
int students[2][7]; 

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, K;
    cin >> N >> K;

    // 1. 데이터 집계 (Counting)
    // 입력을 받아서 성별/학년별로 인원수만 먼저 저장합니다.
    for (int i = 0; i < N; ++i) {
        int gender, grade;
        cin >> gender >> grade;
        students[gender][grade]++;
    }

    // 2. 방 개수 계산 (Calculation)
    int rooms = 0;
    for (int s = 0; s < 2; ++s) {         // 성별 (0, 1)
        for (int y = 1; y <= 6; ++y) {    // 학년 (1 ~ 6)
            int count = students[s][y];
            if (count == 0) continue;     // 학생이 없으면 방도 필요 없음

            // [핵심] (인원수 + K - 1) / K 공식을 사용하여 방 개수 즉시 계산
            rooms += (count + K - 1) / K;
        }
    }

    cout << rooms;
    return 0;
}
```
### 🧐 심화: `(N + K - 1) / K` 공식은 왜 성립할까?

#### 1. 직관적 이해: "부족하면 채워서 보내자!"

우리의 목표는 **N명의 학생**을 **정원 K명의 방(버스)** 에 태우는 것입니다.
C++의 나눗셈(`/`)은 소수점을 가차 없이 버립니다. (내림 연산)

> **상황**: 5명을 4인승 버스에 태워야 함 ($N=5, K=4$)
> - 그냥 나눗셈: $5 / 4 = 1$ (나머지 1명은 버려짐 😱) -> **실패!**
> - 우리는 **2대**의 버스가 필요합니다.

이 문제를 해결하기 위해 **'가상의 인원'** 을 미리 더해주는 꼼수를 씁니다.
바로 **$(K - 1)$명**입니다.

#### 2. 왜 하필 `K - 1`을 더할까?

**"꽉 차기 직전만큼만 미리 더해준다"** 가 핵심입니다.

- 만약 **$K$명(정원만큼)**을 더해버리면?
    - 딱 맞아떨어지는 경우(4명)에도 $(4+4)/4 = 2$가 되어 불필요한 방이 하나 더 생깁니다.
- 그래서 **$K$보다 딱 1 작은수($K-1$)**를 더합니다.
    - 이렇게 하면 **나머지가 1이라도 있으면** 더해진 수와 합쳐져서 몫이 1 올라가고,
    - **나머지가 0이면(딱 맞으면)** 더해진 수가 몫을 올리지 못하고 버려집니다.

#### 3. 예시로 증명하기 ($K=4$일 때)

**CASE A: 나머지가 남는 경우 (5명)**
- 그냥 계산: $5 / 4 = 1$ ... (1명 남음 -> 방 부족)
- **공식 적용**: $(5 + 3) / 4$
    - $= 8 / 4$
    - $= 2$ (**성공!** 남는 1명이 3과 만나 4가 되어 방 하나를 차지함)

**CASE B: 딱 나누어 떨어지는 경우 (4명)**
- 그냥 계산: $4 / 4 = 1$ ... (딱 맞음)
- **공식 적용**: $(4 + 3) / 4$
    - $= 7 / 4$
    - $= 1$ (**성공!** 더해진 3은 4가 되지 못해 소수점과 함께 사라짐)

#### 요약
$$\text{올림 결과} = \frac{\text{인원}(N) + \text{정원}(K) - 1}{\text{정원}(K)}$$
이 공식은 **"나머지가 조금이라도 있다면, 그걸 1으로 만들어줘!"** 라는 명령을 수학적으로 표현한 것입니다.
# [백준] 11328: Strfry

## 1. 문제 정보
- **태그**: #구현 #문자열 #애너그램 #review/30-day/260226
- **난이도**: Bronze II
- **날짜**: 2026-01-16

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 두 문자열이 주어졌을 때, 첫 번째 문자열의 문자를 재배열하여 두 번째 문자열을 만들 수 있는지(즉, 두 문자열의 구성 문자가 동일한지) 판별.
- **핵심 발상**: 
    - 순서와 상관없이 **"각 알파벳이 몇 번 등장했는가?"** 가 핵심입니다.
    - 문자열의 길이가 길지 않고 알파벳 소문자로만 구성되므로, 크기 26짜리 배열을 사용하여 각 문자의 빈도수를 카운팅(Counting)하여 비교합니다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **카운팅 (Counting/Frequency Array)**: 알파벳 'a'~'z'를 0~25 인덱스에 매핑하여 등장 횟수를 저장했습니다.
- **STL 활용**: `std::equal` 함수를 사용하여 두 배열의 내용이 완전히 같은지 직관적으로 확인했습니다.
- **시간 복잡도**: $O(N \times L)$ 
    - $N$: 테스트 케이스의 수
    - $L$: 문자열의 길이 (최대 1000)
    - 각 테스트 케이스마다 문자열을 한 번씩 순회하므로 효율적입니다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **배열 초기화**: 테스트 케이스가 여러 개이므로, 매 반복마다 카운팅 배열(`A`, `B`)이 0으로 초기화되어야 합니다. (작성하신 코드는 `for`문 내부 선언으로 이를 완벽히 처리했습니다.)
- **인덱스 매핑**: `char` 타입을 배열 인덱스로 쓸 때 `'a'`를 빼주어 0~25 범위로 맞추는 것을 잊지 말아야 합니다. (`s[i] - 'a'`)
- **문자열 길이**: 두 문자열의 길이가 다르면 절대 `Possible`이 될 수 없습니다. (빈도수 비교 방식은 길이가 다르면 자연스럽게 `Impossible`이 되므로 별도 처리는 필수는 아니지만, 최적화 포인트가 될 수 있습니다.)

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - **장점**: `std::equal(begin(A), end(A), begin(B))`를 사용하여 반복문 없이 배열을 비교한 점이 매우 세련되고 C++답습니다. 👍
    - **개선점**: 인덱스 기반 `for`문 대신 **Range-based for loop**를 사용하면 코드가 더 간결해집니다.
    - **최적화**: 배열을 2개(`A`, `B`) 만드는 대신, 1개만 만들어서 첫 번째 문자열은 `++`, 두 번째 문자열은 `--` 한 뒤 배열이 모두 0인지 확인하는 방법도 있어 메모리를 절약할 수 있습니다.

```cpp
#include <iostream>
#include <string>
#include <algorithm> // equal 사용을 위해 명시해주면 좋음
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N{};
	cin >> N;
	for (int i{}; i < N; ++i) {
		string s1;
		cin >> s1;
		int A[26]{};
		// [피드백 반영 예시] Range-based for loop
		for (char c : s1) {
			A[c - 'a']++;
		}
		
		string s2;
		cin >> s2;
		int B[26]{};
		for (char c : s2) {
			B[c - 'a']++;
		}

		if (equal(begin(A), end(A), begin(B))) {
			cout << "Possible" << "\n";
		}
		else
			cout << "Impossible" << '\n';
	}
}
```
# [백준] 1919: 애너그램 만들기

## 1. 문제 정보
- **태그**: #문자열 #구현 #배열 #review/30-day/260226 
- **난이도**: 브론즈 II
- **날짜**: 2026-01-16

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 두 영어 단어가 애너그램(철자 구성이 같은 단어) 관계가 되도록 하기 위해 제거해야 하는 최소 문자 개수 구하기.
- **핵심 발상**: 
    1. 애너그램은 **각 알파벳의 개수**가 서로 같아야 한다.
    2. 따라서 각 알파벳(a~z)별로 두 문자열 간의 **개수 차이(절댓값)**를 모두 더하면 제거해야 할 총 개수가 된다.
    - $$Result = \sum_{i=0}^{25} |CountA[i] - CountB[i]|$$

## 3. 알고리즘 & 구현 테크닉 🛠️
- **빈도수 배열 (Frequency Array)**: 알파벳 소문자가 26개임을 이용하여 크기 26짜리 `int` 배열을 만들고, 각 문자의 등장 횟수를 카운팅한다. `index = char - 'a'` 테크닉을 사용.
- **시간 복잡도**: $$O(N)$$
    - 문자열의 길이만큼 순회하며 카운팅($N$) + 알파벳 개수만큼 순회하며 차이 계산(26) = 선형 시간 복잡도.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 범위 초과 (Out of Bounds)**: 
    - 두 문자열의 길이가 다를 수 있으므로, 하나의 `for` 문 안에서 `s1[i]`, `s2[i]`를 동시에 접근하면 짧은 문자열 쪽에서 런타임 에러가 발생한다. 반드시 각각 별도의 루프로 카운팅해야 한다.
- **형 변환 (Narrowing Conversion)**:
    - `string.length()`는 `size_t`를 반환하므로 `int result { ... }`와 같이 중괄호 초기화를 할 때 데이터 손실 경고가 뜰 수 있다.
- **로직 오류**:
    - 단순히 `count`가 같을 때만 처리하거나 다를 때만 처리하는 것이 아니라, **차이(절댓값)** 만큼을 결과에 더해주는 것이 일반화된 풀이이다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `abs` 함수를 사용하여 코드가 매우 간결해졌음.
    - 초기 코드에서 발생했던 길이 차이 문제와 형 변환 문제를 완벽하게 해결함.
    - `ios::sync_with_stdio(0)` 등 입출력 최적화도 잘 적용됨.

```cpp
#include <iostream>
#include <cstdlib> // abs 함수 사용을 위해 권장 (cmath도 가능)
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string s1;
	string s2;
	cin >> s1;
	cin >> s2;
    
	// 알파벳 빈도수 저장 배열 (0으로 초기화)
	int check1[26]{};
	int check2[26]{};
    
	// s1 빈도수 체크 (안전하게 별도 루프)
	for (int i{}; i < s1.length(); ++i) {
		check1[s1[i] - 'a']++;
	}
	// s2 빈도수 체크
	for (int i{}; i < s2.length(); ++i) {
		check2[s2[i] - 'a']++;
	}
    
	int result{}; // 0으로 초기화
	// 각 알파벳 별 개수 차이 누적
	for (int i{}; i < 26; ++i) {
		result += abs(check1[i] - check2[i]);
	}
	cout << result;
}
```
