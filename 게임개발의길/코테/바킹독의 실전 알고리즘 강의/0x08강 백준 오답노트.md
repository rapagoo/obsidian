# [백준] 4949 - 균형잡힌 세상

## 1. 문제 한 줄 요약
- 문자열(한 줄)에서 `()`와 `[]`의 균형(올바른 중첩 포함)이 맞는지 판별한다.

---

## 2. 내가 처음 떠올린 접근
- 스택을 사용해서 여는 괄호는 push, 닫는 괄호는 top이 맞는지 확인 후 pop 한다.

---

## 3. 최종 핵심 아이디어
- 줄 단위로 입력(`getline`)을 받고, 입력이 `.`이면 종료한다.
- `(`, `[`는 push 한다.
- `)`, `]`를 만나면 (1) 스택 비었는지 (2) top 타입이 일치하는지 즉시 검사 후 pop 한다. 불일치면 즉시 실패 처리한다.

---

## 4. 불변식 (Invariant)
- 스택에는 지금까지 처리한 접두사에서 “아직 닫히지 않은 여는 괄호들”만, 올바른 중첩 순서대로 존재해야 한다.

---

## 5. 실수 & 위험 포인트
- 마지막에 스택이 비었는지만 보면 중간 불일치(예: `()]`)를 놓친다.
- 닫는 괄호 처리 시 `st.empty()` 체크 없이 `st.top()`을 보면 런타임 에러 위험이 있다.
- 불일치가 발생한 즉시 실패 플래그(`isError`)로 루프를 중단하는 게 안전하다.

---

## 6. 복습 질문 (Active Recall)
- Q1. 이 문제에서 스택이 의미하는 상태를 불변식으로 한 문장으로 써라.
- Q2. `()]` 케이스를 단계별로 처리했을 때 어디서 실패로 판정해야 하는가?
- Q3. `([)]` 케이스가 실패하는 핵심 이유를 “중첩” 관점에서 설명해라.
- Q4. 한 줄을 끝까지 처리한 후에도 실패가 될 수 있는 조건은 무엇인가?

---

## 7. 복습 스케줄
- #review/30-day/260316

# [백준] 10799: 쇠막대기

## 1. 문제 정보
- **태그**: #자료구조 #스택 #구현 #review/7-day/260219 
- **난이도**: 실버 2
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 괄호 문자열로 표현된 쇠막대기와 레이저의 배치를 보고, 레이저로 절단된 쇠막대기의 총 조각 수를 구하는 문제.
- **핵심 발상**: 
    - 닫는 괄호 `)`가 나왔을 때, 이것이 **레이저**인지 **막대기의 끝**인지 구분하는 것이 가장 중요함.
    - 바로 직전 문자(`s[i-1]`)가 `(`이면 레이저, `)`이면 막대기의 끝임.
    - **레이저(`()`)**: 현재 쌓여있는 막대기 개수(`stack.size()`)만큼 조각 추가.
    - **막대기 끝(`)`)**: 막대기 하나가 닫히므로 마지막 조각 1개 추가.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택(Stack)**: 여는 괄호 `(`는 쇠막대기의 시작을 의미하므로 스택에 넣고, 닫는 괄호 `)`를 만나면 짝을 맞추기 위해 `pop`을 수행함.
- **시간 복잡도**: $O(N)$
    - 문자열의 길이 $N$만큼 한 번만 순회하므로 선형 시간 복잡도를 가짐. (최대 100,000)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 접근 실수**: `s[i-1]`을 확인할 때 `i=0`인 경우 인덱스 에러가 발생할 수 있음.
    - *해결*: 반복문을 1부터 시작하거나, 첫 번째 문자는 별도로 처리해야 함.
- **조각 수 계산 혼동**: 레이저일 때는 `ans += 스택크기`, 막대 끝일 때는 `ans += 1`이라는 점을 명확히 해야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `i`를 0이 아닌 1부터 시작하고, `s[0]`을 미리 스택에 넣어둔 처리가 아주 훌륭함. 덕분에 `if (i > 0 && ...)` 같은 군더더기 조건 없이 깔끔하게 `s[i-1]`을 참조할 수 있었음.
    - **Tip**: 사실 이 문제는 스택에 들어가는 값이 무조건 `(` 뿐이므로, 실제 `stack<char>` 대신 `int` 변수(예: `open_count`)를 하나 써서 `+1`, `-1` 하는 방식으로도 구현 가능함(메모리 절약).

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	string s;
	cin >> s;
	stack<char> st;
	st.push('('); // 첫 번째 문자는 무조건 '(' 이므로 미리 넣음 (인덱스 에러 방지)
	int ans{};
	
	// 인덱스 1부터 시작하여 s[i-1] 참조 시 에러 방지
	for (int i{ 1 }; i < s.size(); ++i) {
		if (s[i] == ')' && s[i - 1] == '(') { // 레이저인 경우
			st.pop(); // 레이저의 짝 '(' 제거
			ans += st.size(); // 현재 겹쳐진 막대기 수만큼 더함
		}
		else if (s[i]=='('){ // 막대기의 시작
			st.push(s[i]);
		}
		else { // 막대기의 끝인 경우
			st.pop(); // 막대기의 짝 '(' 제거
			ans += 1; // 마지막 남은 조각 1개 더함
		}
	}
	cout << ans;
}
```
# [백준] 3986 - 좋은 단어

## 1. 문제 한 줄 요약
- 인접한 같은 문자 쌍을 반복 제거했을 때 문자열이 비면 “좋은 단어”로 센다.

---

## 2. 내가 처음 떠올린 접근
- 스택으로 직전 문자(및 축약 결과)를 유지하면서 같은 문자가 연속되면 제거(pop)한다.

---

## 3. 최종 핵심 아이디어
- 문자 c를 순회한다.
- 스택 top == c 이면 pop (쌍 제거)
- 아니면 push (남겨둔다)
- 끝까지 처리 후 스택 empty면 좋은 단어

---

## 4. 불변식 (Invariant)
- 처리한 접두사에 대해 “인접 동일 문자 제거”를 모두 적용한 축약 결과가 스택에 그대로 유지된다.

---

## 5. 실수 & 위험 포인트
- st.empty() 체크 없이 top() 호출
- 인덱스 반복에서 s.size() 타입과 i 타입 불일치로 경고/버그 가능
- “쌍 제거”는 연쇄적으로 일어날 수 있으므로 항상 스택 기반으로 누적 상태를 유지해야 함

---

## 6. 복습 질문 (Active Recall)
- Q1. 이 알고리즘이 항상 올바른 이유를 불변식으로 설명해보라.
- Q2. ABAB는 왜 실패하고 ABBA는 왜 성공하는가? 스택 변화로 설명해보라.
- Q3. 각 문자가 최대 몇 번 스택 연산을 당하는가? 그래서 시간복잡도는?
- Q4. 이 문제를 “괄호 문자열 판정”과 유사하게 볼 수 있는 관점은 무엇인가?

---

## 7. 복습 스케줄
- #review/7-day/260221

# [백준] 9012 - 괄호

## 1. 문제 한 줄 요약
- 여러 문자열에 대해 괄호 문자열(VPS)인지 판별한다.

---

## 2. 내가 처음 떠올린 접근
- '('는 +1, ')'는 -1로 누적합을 만들고, 중간에 음수가 되면 실패로 처리한다.

---

## 3. 최종 핵심 아이디어
- count로 열린 괄호의 “미해결 개수”를 관리한다.
- 순회 중 count<0이면 이미 닫을 '('가 없으므로 즉시 NO.
- 끝까지 처리 후 `count==0`이면 YES, 아니면 NO.

---

## 4. 불변식 (Invariant)
- 매 순간 count는 “현재까지 남아있는 열린 괄호의 개수”이며, 올바른 괄호 문자열이면 어떤 접두사에서도 count<0이 되지 않고 최종적으로 count=0이다.

---

## 5. 실수 & 위험 포인트
- count가 음수가 되는 케이스를 마지막에만 판단하려 하면 오답(접두사 조건 누락).
- break 없이 끝까지 돌려도 되지만, 조기 종료가 더 안전하고 빠르다.
- 문제 조건(문자 종류 제한)에 기대는 코드 구조는 다른 문제에 재사용 시 위험.

---

## 6. 복습 질문 (Active Recall)
- Q1. “접두사에서 `count<0` 불가”가 왜 필요한가?
- Q2. 마지막에 `count==0`만 확인하면 왜 틀릴 수 있는가? 반례를 들어라.
- Q3. 스택을 쓰면 어떤 상태를 저장하고, count는 그걸 어떻게 요약하는가?
- Q4. 이 로직을 일반 문자열(다른 문자 포함)로 확장하려면 어디를 바꿔야 하는가?

---

## 7. 복습 스케줄
- #review/7-day/260221

