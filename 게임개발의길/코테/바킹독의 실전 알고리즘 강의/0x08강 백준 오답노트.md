# [백준] 4949번: 균형잡힌 세상

## 1. 문제 정보
- **태그**: #스택 #문자열 #자료구조 #review/7-day/260216
- **난이도**: Silver 4
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- **요약**: 소괄호 `()`와 대괄호 `[]`가 포함된 문자열이 주어졌을 때, 괄호의 짝(균형)이 맞는지 판별하는 문제.
- **핵심 발상**: 
    - 괄호 문제는 **LIFO(Last-In, First-Out)** 구조인 **스택(Stack)** 을 사용하는 것이 정석.
    - 여는 괄호 `(`, `[`는 무조건 `push`.
    - 닫는 괄호 `)`, `]`가 나오면 스택의 `top`과 짝이 맞는지 확인 후 `pop`.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **자료구조(Stack)**: 가장 최근에 들어온 여는 괄호와 현재의 닫는 괄호를 매칭하기 위해 사용.
- **문자열 입력**: 공백이 포함된 문장이므로 `cin` 대신 `getline(cin, s)` 사용.
- **시간 복잡도**: $O(N)$
    - 문자열의 길이 $N$만큼 한 번 순회하며 스택 연산($O(1)$)을 수행하므로 선형 시간 복잡도를 가짐.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **단락 평가(Short-circuit evaluation) 주의**: 
    - `if (st.empty() || st.top() != '(')` 순서를 반드시 지켜야 함.
    - 만약 `st.top()`을 `empty()`보다 먼저 검사하면, 스택이 비었을 때 메모리 참조 오류(Runtime Error) 발생.
- **잔여 스택 확인**:
    - 문자열 순회가 끝난 후 `st.empty()`가 `false`라면, 여는 괄호가 남았다는 뜻이므로 균형이 깨진 상태 (`no`).
- **입력 종료 조건**: `.` 하나만 들어왔을 때 루프를 종료하는 조건 확인 필요.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `ios::sync_with_stdio(0)`와 `cin.tie(0)`로 입출력 성능을 잘 최적화했음.
    - `bool isValid` 플래그를 사용하여 중간에 균형이 깨졌을 때 즉시 `break`하고 결과를 도출하는 로직이 깔끔함.
    - `getline` 사용 시 버퍼 문제없이 잘 처리함.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	while (true) {
		string s;
		getline(cin, s);
		bool isValid = true;
		if (s == ".") break;
		stack<char> st;
		for (auto t : s) {
			if (t == '[' || t == '(') {
				st.push(t);
			}
			else if (t == ']') {
				// [중요] empty 체크를 먼저 해야 런타임 에러 방지
				if (st.empty() || st.top() != '[') {
					isValid = false;
					break;
				}
				st.pop();
			}
			else if (t == ')') {
				// [중요] empty 체크를 먼저 해야 런타임 에러 방지
				if (st.empty() || st.top() != '(') {
					isValid = false;
					break;
				}
				st.pop();
			}
		}
		// 순회 후 스택에 괄호가 남아있으면 불균형
		if (!st.empty()) isValid = false;
		
		if (isValid) cout << "yes\n";
		else cout << "no\n";
	}
}
```
# [백준] 10799: 쇠막대기

## 1. 문제 정보
- **태그**: #자료구조 #스택 #구현 #review/7-day/260219 
- **난이도**: 실버 2
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 괄호 문자열로 표현된 쇠막대기와 레이저의 배치를 보고, 레이저로 절단된 쇠막대기의 총 조각 수를 구하는 문제.
- **핵심 발상**: 
    - 닫는 괄호 `)`가 나왔을 때, 이것이 **레이저**인지 **막대기의 끝**인지 구분하는 것이 가장 중요함.
    - 바로 직전 문자(`s[i-1]`)가 `(`이면 레이저, `)`이면 막대기의 끝임.
    - **레이저(`()`)**: 현재 쌓여있는 막대기 개수(`stack.size()`)만큼 조각 추가.
    - **막대기 끝(`)`)**: 막대기 하나가 닫히므로 마지막 조각 1개 추가.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택(Stack)**: 여는 괄호 `(`는 쇠막대기의 시작을 의미하므로 스택에 넣고, 닫는 괄호 `)`를 만나면 짝을 맞추기 위해 `pop`을 수행함.
- **시간 복잡도**: $O(N)$
    - 문자열의 길이 $N$만큼 한 번만 순회하므로 선형 시간 복잡도를 가짐. (최대 100,000)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 접근 실수**: `s[i-1]`을 확인할 때 `i=0`인 경우 인덱스 에러가 발생할 수 있음.
    - *해결*: 반복문을 1부터 시작하거나, 첫 번째 문자는 별도로 처리해야 함.
- **조각 수 계산 혼동**: 레이저일 때는 `ans += 스택크기`, 막대 끝일 때는 `ans += 1`이라는 점을 명확히 해야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `i`를 0이 아닌 1부터 시작하고, `s[0]`을 미리 스택에 넣어둔 처리가 아주 훌륭함. 덕분에 `if (i > 0 && ...)` 같은 군더더기 조건 없이 깔끔하게 `s[i-1]`을 참조할 수 있었음.
    - **Tip**: 사실 이 문제는 스택에 들어가는 값이 무조건 `(` 뿐이므로, 실제 `stack<char>` 대신 `int` 변수(예: `open_count`)를 하나 써서 `+1`, `-1` 하는 방식으로도 구현 가능함(메모리 절약).

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	string s;
	cin >> s;
	stack<char> st;
	st.push('('); // 첫 번째 문자는 무조건 '(' 이므로 미리 넣음 (인덱스 에러 방지)
	int ans{};
	
	// 인덱스 1부터 시작하여 s[i-1] 참조 시 에러 방지
	for (int i{ 1 }; i < s.size(); ++i) {
		if (s[i] == ')' && s[i - 1] == '(') { // 레이저인 경우
			st.pop(); // 레이저의 짝 '(' 제거
			ans += st.size(); // 현재 겹쳐진 막대기 수만큼 더함
		}
		else if (s[i]=='('){ // 막대기의 시작
			st.push(s[i]);
		}
		else { // 막대기의 끝인 경우
			st.pop(); // 막대기의 짝 '(' 제거
			ans += 1; // 마지막 남은 조각 1개 더함
		}
	}
	cout << ans;
}
```
# [백준] 3986 - 좋은 단어

## 1. 문제 한 줄 요약
- 인접한 같은 문자 쌍을 반복 제거했을 때 문자열이 비면 “좋은 단어”로 센다.

---

## 2. 내가 처음 떠올린 접근
- 스택으로 직전 문자(및 축약 결과)를 유지하면서 같은 문자가 연속되면 제거(pop)한다.

---

## 3. 최종 핵심 아이디어
- 문자 c를 순회한다.
- 스택 top == c 이면 pop (쌍 제거)
- 아니면 push (남겨둔다)
- 끝까지 처리 후 스택 empty면 좋은 단어

---

## 4. 불변식 (Invariant)
- 처리한 접두사에 대해 “인접 동일 문자 제거”를 모두 적용한 축약 결과가 스택에 그대로 유지된다.

---

## 5. 실수 & 위험 포인트
- st.empty() 체크 없이 top() 호출
- 인덱스 반복에서 s.size() 타입과 i 타입 불일치로 경고/버그 가능
- “쌍 제거”는 연쇄적으로 일어날 수 있으므로 항상 스택 기반으로 누적 상태를 유지해야 함

---

## 6. 복습 질문 (Active Recall)
- Q1. 이 알고리즘이 항상 올바른 이유를 불변식으로 설명해보라.
- Q2. ABAB는 왜 실패하고 ABBA는 왜 성공하는가? 스택 변화로 설명해보라.
- Q3. 각 문자가 최대 몇 번 스택 연산을 당하는가? 그래서 시간복잡도는?
- Q4. 이 문제를 “괄호 문자열 판정”과 유사하게 볼 수 있는 관점은 무엇인가?

---

## 7. 복습 스케줄
- #review/7-day/260221

# [백준] 9012 - 괄호

## 1. 문제 한 줄 요약
- 여러 문자열에 대해 괄호 문자열(VPS)인지 판별한다.

---

## 2. 내가 처음 떠올린 접근
- '('는 +1, ')'는 -1로 누적합을 만들고, 중간에 음수가 되면 실패로 처리한다.

---

## 3. 최종 핵심 아이디어
- count로 열린 괄호의 “미해결 개수”를 관리한다.
- 순회 중 count<0이면 이미 닫을 '('가 없으므로 즉시 NO.
- 끝까지 처리 후 `count==0`이면 YES, 아니면 NO.

---

## 4. 불변식 (Invariant)
- 매 순간 count는 “현재까지 남아있는 열린 괄호의 개수”이며, 올바른 괄호 문자열이면 어떤 접두사에서도 count<0이 되지 않고 최종적으로 count=0이다.

---

## 5. 실수 & 위험 포인트
- count가 음수가 되는 케이스를 마지막에만 판단하려 하면 오답(접두사 조건 누락).
- break 없이 끝까지 돌려도 되지만, 조기 종료가 더 안전하고 빠르다.
- 문제 조건(문자 종류 제한)에 기대는 코드 구조는 다른 문제에 재사용 시 위험.

---

## 6. 복습 질문 (Active Recall)
- Q1. “접두사에서 `count<0` 불가”가 왜 필요한가?
- Q2. 마지막에 `count==0`만 확인하면 왜 틀릴 수 있는가? 반례를 들어라.
- Q3. 스택을 쓰면 어떤 상태를 저장하고, count는 그걸 어떻게 요약하는가?
- Q4. 이 로직을 일반 문자열(다른 문자 포함)로 확장하려면 어디를 바꿔야 하는가?

---

## 7. 복습 스케줄
- #review/7-day/260221

