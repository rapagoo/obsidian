# [백준] 4949번: 균형잡힌 세상

## 1. 문제 정보
- **태그**: #스택 #문자열 #자료구조 #review/7-day/260216
- **난이도**: Silver 4
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- **요약**: 소괄호 `()`와 대괄호 `[]`가 포함된 문자열이 주어졌을 때, 괄호의 짝(균형)이 맞는지 판별하는 문제.
- **핵심 발상**: 
    - 괄호 문제는 **LIFO(Last-In, First-Out)** 구조인 **스택(Stack)** 을 사용하는 것이 정석.
    - 여는 괄호 `(`, `[`는 무조건 `push`.
    - 닫는 괄호 `)`, `]`가 나오면 스택의 `top`과 짝이 맞는지 확인 후 `pop`.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **자료구조(Stack)**: 가장 최근에 들어온 여는 괄호와 현재의 닫는 괄호를 매칭하기 위해 사용.
- **문자열 입력**: 공백이 포함된 문장이므로 `cin` 대신 `getline(cin, s)` 사용.
- **시간 복잡도**: $O(N)$
    - 문자열의 길이 $N$만큼 한 번 순회하며 스택 연산($O(1)$)을 수행하므로 선형 시간 복잡도를 가짐.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **단락 평가(Short-circuit evaluation) 주의**: 
    - `if (st.empty() || st.top() != '(')` 순서를 반드시 지켜야 함.
    - 만약 `st.top()`을 `empty()`보다 먼저 검사하면, 스택이 비었을 때 메모리 참조 오류(Runtime Error) 발생.
- **잔여 스택 확인**:
    - 문자열 순회가 끝난 후 `st.empty()`가 `false`라면, 여는 괄호가 남았다는 뜻이므로 균형이 깨진 상태 (`no`).
- **입력 종료 조건**: `.` 하나만 들어왔을 때 루프를 종료하는 조건 확인 필요.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `ios::sync_with_stdio(0)`와 `cin.tie(0)`로 입출력 성능을 잘 최적화했음.
    - `bool isValid` 플래그를 사용하여 중간에 균형이 깨졌을 때 즉시 `break`하고 결과를 도출하는 로직이 깔끔함.
    - `getline` 사용 시 버퍼 문제없이 잘 처리함.

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	while (true) {
		string s;
		getline(cin, s);
		bool isValid = true;
		if (s == ".") break;
		stack<char> st;
		for (auto t : s) {
			if (t == '[' || t == '(') {
				st.push(t);
			}
			else if (t == ']') {
				// [중요] empty 체크를 먼저 해야 런타임 에러 방지
				if (st.empty() || st.top() != '[') {
					isValid = false;
					break;
				}
				st.pop();
			}
			else if (t == ')') {
				// [중요] empty 체크를 먼저 해야 런타임 에러 방지
				if (st.empty() || st.top() != '(') {
					isValid = false;
					break;
				}
				st.pop();
			}
		}
		// 순회 후 스택에 괄호가 남아있으면 불균형
		if (!st.empty()) isValid = false;
		
		if (isValid) cout << "yes\n";
		else cout << "no\n";
	}
}
```
# [백준] 10799: 쇠막대기

## 1. 문제 정보
- **태그**: #자료구조 #스택 #구현 #review/3-day/260210
- **난이도**: 실버 2
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 괄호 문자열로 표현된 쇠막대기와 레이저의 배치를 보고, 레이저로 절단된 쇠막대기의 총 조각 수를 구하는 문제.
- **핵심 발상**: 
    - 닫는 괄호 `)`가 나왔을 때, 이것이 **레이저**인지 **막대기의 끝**인지 구분하는 것이 가장 중요함.
    - 바로 직전 문자(`s[i-1]`)가 `(`이면 레이저, `)`이면 막대기의 끝임.
    - **레이저(`()`)**: 현재 쌓여있는 막대기 개수(`stack.size()`)만큼 조각 추가.
    - **막대기 끝(`)`)**: 막대기 하나가 닫히므로 마지막 조각 1개 추가.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택(Stack)**: 여는 괄호 `(`는 쇠막대기의 시작을 의미하므로 스택에 넣고, 닫는 괄호 `)`를 만나면 짝을 맞추기 위해 `pop`을 수행함.
- **시간 복잡도**: $O(N)$
    - 문자열의 길이 $N$만큼 한 번만 순회하므로 선형 시간 복잡도를 가짐. (최대 100,000)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 접근 실수**: `s[i-1]`을 확인할 때 `i=0`인 경우 인덱스 에러가 발생할 수 있음.
    - *해결*: 반복문을 1부터 시작하거나, 첫 번째 문자는 별도로 처리해야 함.
- **조각 수 계산 혼동**: 레이저일 때는 `ans += 스택크기`, 막대 끝일 때는 `ans += 1`이라는 점을 명확히 해야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `i`를 0이 아닌 1부터 시작하고, `s[0]`을 미리 스택에 넣어둔 처리가 아주 훌륭함. 덕분에 `if (i > 0 && ...)` 같은 군더더기 조건 없이 깔끔하게 `s[i-1]`을 참조할 수 있었음.
    - **Tip**: 사실 이 문제는 스택에 들어가는 값이 무조건 `(` 뿐이므로, 실제 `stack<char>` 대신 `int` 변수(예: `open_count`)를 하나 써서 `+1`, `-1` 하는 방식으로도 구현 가능함(메모리 절약).

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	string s;
	cin >> s;
	stack<char> st;
	st.push('('); // 첫 번째 문자는 무조건 '(' 이므로 미리 넣음 (인덱스 에러 방지)
	int ans{};
	
	// 인덱스 1부터 시작하여 s[i-1] 참조 시 에러 방지
	for (int i{ 1 }; i < s.size(); ++i) {
		if (s[i] == ')' && s[i - 1] == '(') { // 레이저인 경우
			st.pop(); // 레이저의 짝 '(' 제거
			ans += st.size(); // 현재 겹쳐진 막대기 수만큼 더함
		}
		else if (s[i]=='('){ // 막대기의 시작
			st.push(s[i]);
		}
		else { // 막대기의 끝인 경우
			st.pop(); // 막대기의 짝 '(' 제거
			ans += 1; // 마지막 남은 조각 1개 더함
		}
	}
	cout << ans;
}
```
# [백준] 3986: 좋은 단어

## 1. 문제 정보
- **태그**: #자료구조 #스택 #review/3-day/260212
- **난이도**: 실버 4
- **날짜**: 2026-02-07

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 같은 글자끼리('A'는 'A', 'B'는 'B') 선을 그어 연결할 때, 선이 서로 교차하지 않으면서 모든 글자를 짝지을 수 있는 단어의 개수 구하기.
- **핵심 발상**: 
    - 선이 교차하지 않는다는 것은 **"괄호 짝 맞추기"** 문제와 논리적으로 동일합니다.
    - 가장 최근에 나온 글자가 지금 들어온 글자와 짝이 맞으면 폭발(소거)시키는 방식이므로 **LIFO(Last-In-First-Out) 구조인 스택**이 필수적입니다.
    - 문자열을 순회하며 스택의 `top`과 현재 문자가 같으면 `pop`, 다르면 `push`를 수행합니다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택(Stack)**: 짝이 맞는 문자를 즉시 제거하여 문자열 내부의 포함 관계를 처리합니다.
- **시간 복잡도**: $O(L)$ (단어 길이 $L$)
    - 각 단어의 문자열을 한 번만 순회하며, 각 문자는 스택에 최대 한 번 들어가고 한 번 나옵니다.
    - 전체 테스트 케이스에 대해 $O(N \times L)$입니다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **문자열 길이가 홀수일 때**: 모든 문자가 짝을 이뤄야 하므로, 길이가 홀수라면 절대 '좋은 단어'가 될 수 없습니다. (빠른 가지치기 가능)
- **스택 잔여물 확인**: 반복문이 끝난 후 스택이 **비어 있어야만(`empty`)** 모든 짝이 맞았다는 뜻입니다.
- **`top()` 호출 전 확인**: 스택이 비어있는데 `st.top()`을 호출하면 런타임 에러가 발생하므로, 반드시 `!st.empty()` 체크를 선행해야 합니다.

## 5. 내 코드 & 피드백
- **코드 리뷰**:
    - `s[0]`를 미리 넣고 반복문을 `1`부터 시작하는 방식도 좋지만, 빈 문자열이 들어올 경우 인덱스 에러가 날 수 있습니다. 반복문을 `0`부터 시작하고 스택이 비어있으면 무조건 `push`하는 로직으로 통일하면 코드가 더 간결하고 안전해집니다.
    - `ios::sync_with_stdio(0)` 등의 입출력 최적화는 아주 좋습니다.

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N;
	cin >> N;
	int res{};
	while (N--) {
		string s;
		cin >> s;
		stack<char> st;
		
		// [피드백 반영 가능] 0번 인덱스부터 균일하게 처리하면 더 안전함
		st.push(s[0]);
		for (int i{ 1 }; i < s.size(); ++i) {
			if (!st.empty() && st.top() == s[i]) {
				st.pop();
			}
			else {
				st.push(s[i]);
			}
		}
		if (st.empty()) res++;
	}
	cout << res;
}
```
# [백준] 9012: 괄호

## 1. 문제 정보
- **태그**: #자료구조 #문자열 #스택 #review/3-day/260212 
- **난이도**: 실버 4
- **날짜**: 2026-02-07

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 주어진 괄호 문자열이 올바른 괄호 문자열(VPS)인지 판단하여 YES/NO 출력.
- **핵심 발상**: 
  - 괄호의 짝이 맞는지 확인하는 전형적인 스택 문제지만, **단순 카운팅(Integer)** 만으로도 해결 가능합니다.
  - `(` 는 `+1`, `)` 는 `-1`로 계산했을 때, **중간에 음수가 되면 안 되고 최종 합은 0이어야 한다**는 점이 핵심입니다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택(Stack)의 경량화 (카운터 변수 사용)**: 
  - 굳이 `std::stack`을 선언해서 `push/pop` 할 필요 없이, `int count` 변수 하나로 스택의 깊이(Depth)만 추적하여 공간 복잡도를 줄였습니다.
- **시간 복잡도**: O(N)
  - 문자열의 길이 $N$만큼 한 번 순회하며 검사하므로 선형 시간이 소요됩니다. $N$이 최대 50이라 매우 빠릅니다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **음수 체크 (`count < 0`)**: 
  - 문자열 순회 도중 `)`가 `(`보다 많아지는 순간(count가 -1이 되는 순간) 즉시 **오답(NO)** 처리하고 루프를 빠져나와야 합니다.
- **잔여 괄호 체크 (`count != 0`)**: 
  - 순회가 끝났을 때 `count`가 양수라면, 여는 괄호 `(`가 닫히지 않고 남았다는 뜻이므로 **오답(NO)** 입니다.
- **초기화**: 
  - 테스트 케이스(`T`)가 여러 개이므로 매 반복마다 `count`와 `isError` 변수를 초기화해야 합니다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
  - `std::stack`을 사용하지 않고 `int` 변수로 처리한 점이 아주 효율적입니다. 메모리 사용량을 최소화했습니다.
  - `ios::sync_with_stdio(0); cin.tie(0);`를 통해 C++ 입출력 속도를 최적화한 점도 훌륭합니다.
  - `break`를 통해 불필요한 연산을 줄인 로직이 깔끔합니다.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        int count = 0;
        bool isError = false;
        for (char c : s) { 
            if (c == '(') {
                count++;
            }
            else {
                count--;
                if (count < 0) { 
                    isError = true;
                    break;
                }
            }
        }

        if (!isError && count == 0) cout << "YES\n";
        else cout << "NO\n";
    }

    return 0;
}