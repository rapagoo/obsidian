# [백준] 1021번: 회전하는 큐

## 1. 문제 정보
- **태그**: #자료구조 #덱 #시뮬레이션 #구현 #review/7-day/260218
- **난이도**: Silver 3
- **날짜**: 2026-01-22

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 1부터 N까지의 원소가 든 큐에서, 주어진 숫자들을 순서대로 뽑아내는 데 필요한 **'2번(왼쪽 회전)과 3번(오른쪽 회전) 연산의 최솟값'** 을 구하는 문제.
- **핵심 발상**: 
    - 뽑으려는 원소가 현재 덱의 **중간 지점**보다 앞에 있으면 왼쪽으로, 뒤에 있으면 오른쪽으로 돌리는 것이 이득이다.
    - 매번 원소를 뽑을 때마다(`pop_front`) 인덱스가 바뀌므로, **매 단계마다 타겟의 위치(index)를 새로 찾아야 한다.**

## 3. 알고리즘 & 구현 테크닉 🛠️
- **Deque (덱)**: 양쪽 끝에서 삽입/삭제가 가능하여 회전 연산을 구현하기 적합함.
- **STL 활용**: 
    - `std::find`: 덱 내부에서 타겟 값의 반복자(iterator)를 찾음.
    - `std::distance`: 반복자 간의 거리를 계산하여 정수형 인덱스로 변환.
- **그리디(Greedy)**: 현재 상태에서 가장 비용이 적은 방향(좌/우)을 선택하면 전체 최솟값이 됨.
- **시간 복잡도**: **O(N * M)**
    - 타겟 탐색(`find`)에 O(N), 회전 연산에 최대 O(N)이 소요되며 이를 M번 반복함. 
    - N이 최대 50이라 충분히 통과 가능.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **축소 변환 (Narrowing Conversion)**: 
    - `it - dq.begin()`의 결과는 `long` 타입(혹은 `ptrdiff_t`)이므로 `int` 변수에 `{}` 초기화로 넣으면 컴파일 에러가 발생할 수 있음. `static_cast<int>`나 등호(`=`) 사용이 필요함.
- **방향 판단 로직**:
    - `index` (왼쪽 이동 횟수) vs `dq.size() - index` (오른쪽 이동 횟수)를 비교해야 함.
    - 등호 처리를 꼼꼼히 하여 짝수/홀수 크기일 때 모두 대응해야 함.
- **상태 변화**: `pop_front`를 하고 나면 덱의 크기가 줄어들므로, 다음 타겟을 찾을 때 바뀐 인덱스를 기준으로 다시 계산해야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - 초기에는 `while`문 내에서 값만 비교하여 무한 루프에 빠졌으나, **인덱스 기반**으로 수정하여 해결함.
    - `static_cast<int>(distance(...))`를 사용하여 타입 안정성을 확보한 점이 매우 훌륭함.
    - 회전 횟수를 미리 계산하고 `for`문으로 처리하여 로직이 명확해짐.

```cpp
#include <iostream>
#include <algorithm>
#include <deque>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N, M;
	cin >> N >> M;
	deque<int> dq;
	for (int i{}; i < N; ++i) {
		dq.push_back(i + 1);
	}
	int count{};
	for (int i{}; i < M; ++i) {
		int x;
		cin >> x;
		// 1. 타겟의 현재 위치(iterator) 찾기
		auto it = find(dq.begin(), dq.end(), x);
		// 2. iterator를 인덱스(int)로 변환 (축소 변환 방지)
		int index = static_cast<int>(distance(dq.begin(), it));
		
		// 3. 왼쪽 회전이 빠른지, 오른쪽 회전이 빠른지 판단
		if (dq.size() - index >= index) {
			// 왼쪽으로 회전 (2번 연산)
			for (int j{}; j < index; ++j) {
				dq.push_back(dq.front());
				dq.pop_front();
				count++;
			}
		}
		else {
			// 오른쪽으로 회전 (3번 연산)
			for (int j{}; j < dq.size() - index; ++j) {
				dq.push_front(dq.back());
				dq.pop_back();
				count++;
			}
		}
		// 4. 맨 앞으로 온 원소 삭제 (1번 연산)
		dq.pop_front();
	}
	cout << count;
}
```
# [백준] 5430: AC

## 1. 문제 정보
- **태그**: #구현 #자료구조 #덱 #파싱 #문자열 #review/7-day/260219
- **난이도**: Gold 5
- **날짜**: 2026-02-04

## 2. 문제 요약 & 핵심 아이디어 💡
- 정수 배열에 대해 'R'(뒤집기)과 'D'(버리기) 연산을 수행한 최종 결과를 구하는 문제.
- **핵심 발상**: 
  - 실제로 배열을 뒤집는 연산은 $O(N)$이 소요되므로, 명령어마다 수행하면 **시간 초과**가 발생함.
  - **`reversed` 플래그(Boolean)** 하나를 두어, 현재 배열이 뒤집힌 상태인지 아닌지만 기억한다.
  - 뒤집힌 상태라면 `pop_back()`, 아니라면 `pop_front()`를 수행하여 물리적 이동을 최소화함.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **덱(Deque)**: 양쪽 끝에서 삽입/삭제가 모두 $O(1)$인 자료구조가 필수적임.
- **Lazy Update (지연 갱신)**: 매번 뒤집지 않고, 마지막 출력 직전에만 상태를 확인해 실제 뒤집기(또는 역순 출력)를 수행함.
- **시간 복잡도**: $O(N)$ 
  - 파싱 및 덱 초기화: $O(N)$
  - 명령어 처리(K개): $O(K)$ (각 연산은 $O(1)$)
  - 최종 출력: $O(N)$
  - 총합 $O(N+K)$로 제한 시간 내 통과 가능.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **빈 배열 처리 (`[]`)**: 입력이 빈 배열일 때 `n=0`이지만 문자열은 `[]`로 들어옴. 파싱 로직에서 이를 예외 처리 없이 잘 넘기는지 확인 필요.
- **두 자릿수 이상 숫자 파싱**: `string` 입력이 `[1,12,123]` 형태이므로 단순히 한 글자씩 읽으면 안 되고, 쉼표(`,`)나 괄호(`]`)가 나올 때까지 숫자를 누적해서(`cur = cur * 10 + digit`) 계산해야 함.
- **출력 형식**: 빈 덱일 때 `[]`를 출력해야 하며, 숫자 사이에는 공백 없이 콤마(`,`)만 있어야 함.

## 5. 내 코드 & 피드백
- **코드 리뷰**:
  - `deque`와 `bool reversed` 플래그를 사용하여 문제의 의도에 맞게 효율적으로 잘 구현했습니다.
  - **파싱 로직 (`parse` 함수)**: `if (cur != 0)` 조건으로 마지막 숫자를 넣는데, 문제 조건상 숫자가 $1$ 이상($1 \le x \le 100$)이라 문제없지만, 만약 입력 데이터에 **0**이 포함될 수 있다면 이 로직은 `0`을 무시하게 되므로 주의가 필요합니다. (보편적인 파싱 로직으로는 콤마나 괄호를 기준으로 확실하게 `push` 하는 것이 더 안전합니다.)
  - 마지막 출력 전 `reverse(dq.begin(), dq.end())`를 사용했는데, `reversed` 상태에 따라 반복문을 거꾸로 돌며 출력하는 방법도 있습니다. (현재 방식도 $O(N)$이라 성능상 문제는 없습니다!)

```cpp
#include <iostream>
#include <deque>
#include <algorithm>
#include <string>

using namespace std;

void parse(string& s, deque<int>& dq) {
	int cur{};
	// 인덱스 범위 처리가 깔끔하지만, 빈 배열 [] 입력 시 루프가 돌지 않도록 조건 설정됨
	for (int i{ 1 }; i+1 < s.size(); ++i) {
		if (s[i] == ',') {
			dq.push_back(cur);
			cur = 0;
		}
		else {
			cur = 10 * cur + (s[i] - '0');
		}
	}
	// 주의: 입력 데이터에 0이 있다면 이 조건문 때문에 0이 삽입되지 않을 수 있음 (현재 문제는 1~100이라 무관)
	if (cur != 0) {
		dq.push_back(cur);
	}
}

void print_result(deque<int>& dq) {
	cout << '[';
	for (int i{}; i < dq.size(); ++i) {
		cout << dq[i];
		if (i + 1 != dq.size()) {
			cout << ',';
		}
	}
	cout << "]\n";
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int T;
	cin >> T;
	while (T--) {
		deque<int> dq;
		string op;
		cin >> op;
		bool reversed{};
		bool isError{};
		int n;
		cin >> n;
		string tmp;
		cin >> tmp;
		parse(tmp, dq);
		for (char c : op) {
			if (c == 'R') {
				reversed = !reversed;
			}
			else {
				if (dq.empty()) {
					isError = true;
					break;
				}
				if (reversed) dq.pop_back();
				else dq.pop_front();
				}
		}
		if (isError)
			cout << "error\n";
		else {
			// 실제 뒤집기 수행 (출력용)
			if (reversed) reverse(dq.begin(), dq.end());
			print_result(dq);
		}
	}
}
```
