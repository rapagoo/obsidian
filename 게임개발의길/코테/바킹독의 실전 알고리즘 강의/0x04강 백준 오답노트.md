# [백준] 1406: 에디터

## 1. 문제 정보
- **태그**: #자료구조 #연결리스트 #구현 #review/30-day/260304
- **난이도**: Silver II
- **날짜**: 2026-01-19

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 커서를 기준으로 문자를 추가(P), 삭제(B), 이동(L, D)하는 편집기 시뮬레이션 
- **핵심 발상**:
    - 일반적인 배열나 `std::string`을 쓰면 중간 삽입/삭제에 $O(N)$이 걸려 시간 초과가 발생함.
    - **연결 리스트(Linked List)** 를 사용하면 삽입/삭제가 $O(1)$로 가능함.
    - `cursor`를 `iterator`로 관리하여 리스트의 특정 위치를 가리키게 하는 것이 포인트.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **Doubly Linked List (`std::list`)**:
    - C++ STL의 `list`를 사용하여 구현.
    - `insert(iterator, val)`: iterator가 가리키는 위치 **앞에** 삽입.
    - `erase(iterator)`: iterator가 가리키는 요소를 삭제하고 **다음 요소의 iterator를 반환**. 
- **시간 복잡도**: $O(M)$ (초기 문자열 길이는 $N$이지만 입력 시 $O(N)$, 이후 $M$개의 명령어는 모두 $O(1)$)
    - 총 연산 횟수가 최대 60만 번 정도라 0.3초 제한 내에 충분히 통과 가능.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **`erase` 함수의 반환값 처리**:
    - `L.erase(cursor)`를 실행하면 `cursor`가 무효화됨(dangling iterator).
    - 반드시 `cursor = L.erase(cursor);` 형태로 반환되는 유효한 반복자를 다시 받아야 함.
- **삭제(`B`) 시 커서 위치**:
    - 커서가 가리키는 문자가 아니라 **커서 왼쪽** 문자를 지워야 함.
    - 따라서 `cursor--`로 왼쪽으로 이동 후 삭제해야 하며, 이때 `begin()`인지 체크 필수.
- **예외 처리**:
    - 커서가 맨 앞(`begin()`)일 때 `L`, `B` 명령 무시.
    - 커서가 맨 뒤(`end()`)일 때 `D` 명령 무시.

## 5. 내 코드 & 피드백
- **코드 리뷰**:
    - `ios::sync_with_stdio(0)`로 입출력 속도를 잘 최적화했음.
    - `switch-case` 문을 사용하여 명령어 처리를 깔끔하게 구조화함.
    - **개선점**: `B` 명령 처리 시 `if (cursor != L.begin())` 내부에 `cursor--`, `erase` 로직을 넣은 것은 아주 정확한 판단임. 이 조건문이 없으면 런타임 에러가 발생할 수 있음.
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	string s;
	cin >> s;
	list<char> L;
	for (auto t : s) {
		L.push_back(t);
	}
	
	// 초기 커서는 문장의 맨 뒤(end)에 위치
	auto cursor{ L.end() };
	
	int N{};
	cin >> N;
	for (int i{}; i < N; ++i) {
		char input{};
		cin >> input;
		switch (input) {
		case 'P':
			char add;
			cin >> add;
			L.insert(cursor, add); // 커서 왼쪽에 문자 추가
			break;
		case 'L':
			if (cursor != L.begin()) cursor--; // 왼쪽으로 한 칸 이동
			break;
		case 'D':
			if (cursor != L.end()) cursor++; // 오른쪽으로 한 칸 이동
			break;
		case 'B':
			// 커서가 맨 앞이 아닐 때만 삭제 수행
			if (cursor != L.begin()) {
				cursor--; // 지울 문자로 이동 (커서 왼쪽 문자)
				cursor = L.erase(cursor); // 삭제 후, 그다음 위치로 커서 갱신
			}
			break;
		}
	}
	for (auto c : L) cout << c;
}
```
# [백준] 5397: 키로거

## 1. 문제 정보
- **태그**: #자료구조 #연결리스트 #스택 #구현 #review/30-day/260304 
- **난이도**: Silver II
- **날짜**: 2026-01-19

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 강산이가 입력한 키로그(알파벳, 화살표, 백스페이스)를 바탕으로 최종 비밀번호 알아내기.
- **핵심 발상**: 
    - 문자열의 길이가 최대 1,000,000이다. 배열이나 벡터를 사용하여 중간 삽입/삭제를 하면 $O(N)$이 걸려 전체 $O(N^2)$로 시간 초과가 발생한다.
    - 따라서 중간 삽입/삭제가 $O(1)$인 **연결 리스트(Linked List)** 를 사용해야 한다.
    - `cursor`라는 이터레이터를 이용해 현재 편집 위치를 추적하는 것이 관건.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **std::list (Doubly Linked List)**: C++ STL의 `list`를 사용하여 구현.
- **Iterator (반복자)**: 리스트 내의 위치를 가리키는 `cursor`를 활용.
- **시간 복잡도**: $O(L)$ (L은 문자열의 길이)
    - 리스트의 삽입/삭제/이동 연산은 모두 상수 시간 $O(1)$에 처리되므로, 입력 문자열을 한 번 순회하면 끝난다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **insert와 커서의 위치**: `L.insert(cursor, val)` 수행 시, 값은 커서의 **왼쪽**에 들어간다. 중요한 점은 **커서(Iterator) 자체는 여전히 기존 요소를 가리키고 있다는 것**이다.
    - 시각적으로는 커서가 이미 새 글자의 오른쪽에 위치하게 되므로, `++cursor`를 추가로 해주면 안 된다. (이 부분에서 런타임 에러가 발생했었음)
- **erase와 반환값**: `L.erase(iter)`는 해당 요소를 삭제하고 해당 이터레이터를 무효화시킨다. 반드시 **삭제된 요소 다음을 가리키는 이터레이터**를 반환받아 갱신해야 한다.
    - 구현: `cursor = L.erase(--cursor);` (커서 왼쪽을 지우고, 커서 위치 갱신)
- **경계 처리**: 커서가 `begin()`일 때 왼쪽 이동/삭제 불가, `end()`일 때 오른쪽 이동 불가 조건 필수.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `ios::sync_with_stdio(0)`를 사용하여 입출력 속도를 잘 최적화했다.
    - 반복문 내에서 `insert` 후 불필요한 커서 이동을 제거하여 정확한 로직을 구현했다.
    - `list`의 특성을 완벽하게 이해하고 활용한 모범 답안이다.

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N{};
	cin >> N;
	for (int i{}; i < N; ++i) {
		string s;
		cin >> s;
		list<char> L;
		auto cursor{ L.begin() };
		
		for (auto t : s) {
			if (t == '<') {
				if (cursor != L.begin()) --cursor;
			}
			else if (t == '>') {
				if (cursor != L.end()) ++cursor;
			}
			else if (t == '-') {
				if (cursor != L.begin()) cursor = L.erase(--cursor);
			}
			else {
				// insert는 cursor가 가리키는 요소 '앞'에 삽입함.
				// 삽입 후에도 cursor는 여전히 같은 요소를 가리키므로
				// 시각적으로는 새 문자의 '뒤'에 위치하게 됨. (별도 이동 불필요)
				L.insert(cursor, t);
			}
		}
		
		for (auto t : L) {
			cout << t;
		}
		cout << '\n';
	}
}
```
# [백준] 1158: 요세푸스 문제

## 1. 문제 정보
- **태그**: #구현 #자료구조 #연결리스트 #큐 #review/30-day/260305
- **난이도**: 실버 4
- **날짜**: 2026-01-19

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 1번부터 N번까지 원형으로 앉은 사람들 중, 순서대로 K번째 사람을 제거하는 과정을 반복하여 제거된 순서를 출력한다.
- **핵심 발상**: 
    1. **원형 구조 시뮬레이션**: 선형 자료구조(`list`)를 사용하되, 끝(`end`)에 도달하면 다시 처음(`begin`)으로 반복자를 이동시켜 원형처럼 동작하게 만든다.
    2. **삭제 후처리**: 요소를 삭제한 후, 반복자가 유효한 다음 위치를 가리키도록 갱신해야 한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **연결 리스트(Linked List)**: 중간 요소를 삭제할 때 `std::vector`보다 효율적인 `std::list`를 사용했다.
    - `erase` 연산: $O(1)$ (상수 시간)
- **반복자(Iterator) 관리**: 
    - `cursor = L.erase(cursor)`: 삭제된 원소의 **다음** 위치를 반환받아 흐름을 유지한다.
    - `if (cursor == L.end()) cursor = L.begin()`: 리스트의 끝을 만나면 처음으로 연결한다.
- **시간 복잡도**: $O(N \times K)$
    - 총 $N$명을 제거해야 하고, 한 명을 제거할 때마다 $K$번 이동하므로 $NK$만큼 연산한다. ($N, K \le 5000$이므로 약 2,500만 연산, 2초 내 통과 충분)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **Iterator Invalidation (반복자 무효화)**: `L.erase(cursor)`를 한 뒤 반환값을 받지 않고 그냥 `cursor++`를 하면, 이미 삭제된 메모리를 참조하게 되어 런타임 에러가 발생한다.
- **출력 형식**: `<3, 6, 2, ...>` 처럼 쉼표와 괄호를 맞춰야 한다. 특히 **마지막 숫자 뒤에는 쉼표가 없어야** 하므로, 마지막 원소는 반복문 밖에서 처리하거나 별도 조건을 줘야 한다.
- **초기화 순서**: `count`를 먼저 증가시키고 비교할지, 비교하고 증가시킬지에 따라 로직이 달라지므로 일관성이 중요하다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `std::list`의 특성을 아주 잘 활용했다. 특히 `erase`의 반환값을 받아 반복자를 갱신하는 부분이 정확하다.
    - `result.back()`을 사용하여 마지막 원소 출력 처리를 깔끔하게 해결했다.
    - **참고**: 이 문제는 `std::queue`를 사용하여 "앞에서 꺼내 뒤로 넣기(push & pop)" 방식으로 구현하면 반복자 관리 없이도 풀 수 있다. (코드 길이는 큐가 더 짧을 수 있음)

```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main() {
	int N, K;
	cin >> N >> K;

	vector<int> result;
	list<int> L;

	// 1~N까지 리스트 채우기
	for (int i{}; i < N; ++i) {
		L.push_back(i + 1);
	}

	int count{};
	auto cursor{ L.begin() };

	// 리스트가 빌 때까지 반복
	while (!L.empty()) {
		count++;
		if (count % K == 0) {
			// K번째면 결과에 저장하고 리스트에서 삭제
			result.push_back(*cursor);
			cursor = L.erase(cursor); // 삭제 후 다음 위치로 갱신
		}
		else {
			// K번째가 아니면 다음 사람으로 이동
			cursor++;
		}

		// 끝에 도달하면 처음으로 이동 (원형 구조)
		if (cursor == L.end()) cursor = L.begin();
	}

	// 출력 형식 맞추기 (<, , >)
	cout << '<';
	for (int i{}; i < result.size() - 1; ++i) {
		cout << result[i] << ", ";
	}
	cout << result.back() << '>';
}
```
