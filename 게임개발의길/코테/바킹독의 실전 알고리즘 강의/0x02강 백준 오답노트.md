# [백준] 2309: 일곱 난쟁이
## 1. 문제 정보
- **태그**: #브루트포스 #정렬 #구현 #review/30-day/260220
- **난이도**: 브론즈 1
- **날짜**: 2026-01-08

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 아홉 명의 난쟁이 중 키의 합이 100이 되는 일곱 명을 찾아 오름차순으로 출력하기.
- **핵심 발상**: 
    - 7명을 뽑는 조합을 생각하기보다, **전체 9명 중 제외할 2명(가짜)을 찾는 것**이 훨씬 효율적이다.
    - $Total Sum - (A + B) = 100$ 을 만족하는 $A, B$를 찾는다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **브루트포스 (Brute Force)**: 9명 중 2명을 뽑는 모든 경우의 수(${}_{9}\mathrm{C}_{2}$)를 이중 `for`문으로 탐색.
- **정렬 (Sorting)**: 
    - 찾은 두 명의 값을 `0`으로 변경 후 정렬(`std::sort`).
    - 이렇게 하면 `0`인 값들이 배열의 앞쪽(인덱스 0, 1)으로 이동하므로, 인덱스 2부터 출력하면 된다.
- **시간 복잡도**: $O(N^2)$ 
    - $N=9$이므로 매우 작아 순식간에 계산됨.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **조기 종료 필수**: 답이 여러 개일 경우 하나만 출력해야 하므로, 정답을 찾으면 반드시 `return 0;` 혹은 `break` 등을 통해 반복문을 탈출해야 한다. (계속 돌면 오답 가능성 있음)
- **인덱스 처리**: 이중 반복문 범위 설정 시 `j`는 항상 `i + 1`부터 시작해야 중복을 피할 수 있다.
- **수식 실수**: `total - (dwarf[i] + dwarf[j])` 괄호 처리에 유의.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `return 0;`를 활용해 `flag` 변수 없이도 깔끔하게 프로그램을 종료한 점이 훌륭함.
    - 가짜 난쟁이를 제거하는 대신 `0`으로 마킹하고 정렬을 이용해 필터링한 로직이 창의적임.

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int dwarf[9]{};
	int total{};
	for (int i{}; i < 9; i++) {
		cin >> dwarf[i];
		total += dwarf[i];
	}
	for (int i{}; i < 8; i++) {
		for (int j{ i + 1 }; j < 9; j++) {
			if (total - (dwarf[i] + dwarf[j]) == 100) {
				dwarf[i] = 0;
				dwarf[j] = 0;
				sort(dwarf, dwarf + 9);
				for (int k{ 2 }; k < 9; k++) {
					cout << dwarf[k] << '\n';
				}
				return 0;
			}
		}
	}
}
```
# [백준] 1267: 핸드폰 요금

## 1. 문제 정보
- **태그**: #수학 #사칙연산 #구현 
- **난이도**: 브론즈 III
- **날짜**: 2026-01-13

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 영식 요금제(30초당 10원)와 민식 요금제(60초당 15원) 중 더 저렴한 요금제와 총 요금을 출력한다. (같으면 둘 다 출력)
- **핵심 발상**:
    - 요금이 부과되는 구간을 **수식으로 일반화**하는 것이 핵심이다.
    - C++의 정수 나눗셈(버림) 특성을 역이용하여, 특정 값을 더한 뒤 나누는 방식으로 **구간에 따른 요금 부과 횟수**를 한 번에 구한다.
    - **영식 요금제 ($Y$)**: $(T + 30) / 30 \times 10$
        - 예: 29초 $\rightarrow (29+30)/30 = 1$구간 (10원)
        - 예: 30초 $\rightarrow (30+30)/30 = 2$구간 (20원)
    - **민식 요금제 ($M$)**: $(T + 60) / 60 \times 15$

## 3. 알고리즘 & 구현 테크닉 🛠️
- **단순 수학 (Math)**: `if-else`나 나머지 연산(`%`)을 사용하지 않고, 덧셈과 나눗셈만으로 요금 구간을 계산하여 코드를 간결하게 만들었다.
- **시간 복잡도**: $O(N)$
    - 통화의 개수 $N$만큼 반복문을 순회하며 단순 사칙연산을 수행하므로 매우 빠르다. ($N \le 20$이므로 사실상 $O(1)$에 가깝다.)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **출력 형식**: 두 요금제의 총액이 **같을 경우** `Y M {요금}` 순서로 공백을 두고 출력해야 한다. 조건을 빠뜨리기 쉽다.
- **초기화**: 누적 합을 구하는 변수(`Y`, `M`)는 반드시 0으로 초기화해야 한다. (C++의 `int Y{};` 문법은 0으로 자동 초기화됨을 활용함)
- **나눗셈 식 세우기**: `(T / 30) * 10`으로 단순히 계산하면 29초일 때 0원이 되어버리는 오류가 발생한다. 반드시 오프셋(30)을 더해주어야 한다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `ios::sync_with_stdio(0); cin.tie(0);`를 사용하여 입출력 성능을 최적화한 점이 훌륭하다.
    - 변수 선언 시 `int N{};`과 같이 Uniform Initialization을 사용하여 초기화 실수를 방지한 점이 좋다.
    - 복잡한 조건문 없이 수식 한 줄로 로직을 처리하여 가독성이 매우 높다.

```cpp
#include <iostream>
using namespace std;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int N{};
	int Y{};
	int M{};
	cin >> N;
	for (int i{}; i < N; ++i) {
		int input{};
		cin >> input;
		// 핵심 로직: (시간 + 기준시간) / 기준시간 * 단위요금
		Y += ((input + 30) / 30) * 10;
		M += ((input + 60) / 60) * 15;
	}
	
	// 결과 비교 및 출력
	if (Y > M) {
		cout << "M " << M;
	}
	else if (Y < M) {
		cout << "Y " << Y;
	}
	else cout << "Y M " << Y;
}
```
# [백준] 10804: 카드 역배치

## 1. 문제 정보
- **태그**: #구현 #시뮬레이션 #STL #review/30-day/260225
- **난이도**: 브론즈 II
- **날짜**: 2026-01-14

## 2. 문제 요약 & 핵심 아이디어 💡
- **요약**: 1부터 20까지 오름차순으로 놓인 카드들을, 주어진 10개의 구간 $[a, b]$에 대해 순서를 뒤집은(역배치) 결과를 출력하는 문제.
- **핵심 발상**: 
    - 단순 정렬(Sort)이 아니라 **순서를 뒤집는(Reverse)** 작업임.
    - C++ STL의 `std::reverse` 함수를 활용하면 반복문 없이 깔끔하게 구현 가능.
    - 입력은 **1-based index**이고, 배열/벡터는 **0-based index**이므로 인덱스 변환에 유의해야 함.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **std::reverse(begin, end)**: 
    - `<algorithm>` 헤더에 포함된 함수.
    - 범위 `[begin, end)` 사이의 요소들을 뒤집음.
    - **중요**: 두 번째 인자 `end`는 뒤집으려는 **마지막 요소의 바로 다음 위치**를 가리켜야 함.
- **시간 복잡도**: $O(1)$
    - 배열의 크기가 20으로 고정되어 있고, 연산 횟수도 10회로 고정되어 있어 사실상 상수 시간 복잡도를 가짐.
    - 일반화한다면 $O(M \times N)$ (M: 구간 개수, N: 구간 길이).

## 4. 주의할 점 & 오답 포인트 ⚠️
- **반복자(Iterator) 범위 설정 실수**:
    - `reverse` 함수의 범위는 **반닫힌 구간 \[Start, End)** 임.
    - 입력받은 범위가 $S, E$ (1부터 시작)일 때:
        - 시작 위치: `A.begin() + S - 1` (0-based로 변환)
        - 끝 위치: `A.begin() + E` (E번째 요소까지 포함해야 하므로, 반복자는 그 다음인 E를 가리켜야 함)
    - 만약 `A.end()`를 기준으로 잡으려 하면 계산이 매우 복잡해지므로 `A.begin()` 기준으로 오프셋을 더하는 것이 안전함.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `vector`를 사용하여 메모리 관리를 편하게 했고, 초기화(`int i{}`) 문법도 모던 C++ 스타일로 잘 작성했음.
    - 가장 헷갈리기 쉬운 `reverse`의 **끝 반복자 처리**(`A.begin()+E`)를 정확하게 수정하여 정답을 도출함.
    - 범위 기반 for문(`for (int a : A)`)을 사용하여 출력 가독성을 높임.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	// 1. 1~20 숫자로 벡터 초기화
	vector<int> A(20);
	for (int i{}; i < 20; ++i) {
		A[i] = i + 1;
	}

	// 2. 10개의 구간 입력받아 역배치 수행
	for (int i{}; i < 10; ++i) {
		int S{};
		int E{};
		cin >> S >> E;
		
		// 핵심: 0-based index 변환 및 반복자 범위 설정
		// 시작: S-1 (인덱스)
		// 끝: E (E-1 인덱스까지 포함하기 위해 E를 전달)
		reverse(A.begin() + S - 1, A.begin() + E);
	}

	// 3. 결과 출력
	for (int a : A) {
		cout << a << ' ';
	}
}
```
# [백준] 2444: 별 찍기 - 7

## 1. 문제 정보
- **태그**: #구현 #문자열 #수학 
- **난이도**: 브론즈 III
- **날짜**: 2026-01-14

## 2. 문제 요약 & 핵심 아이디어 💡
- 정수 N을 입력받아 마름모(다이아몬드) 꼴로 별을 출력하는 문제.
- **핵심 발상**: 
    1. **대칭 구조**: 상단 삼각형($1$행 ~ $N$행)과 하단 역삼각형($N+1$행 ~ $2N-1$행)을 나누어 생각한다.
    2. **등차수열 규칙 찾기**: 
       - 상단은 별이 2개씩 증가 ($1, 3, 5 \dots$)
       - 하단은 별이 2개씩 감소 ($2N-3, 2N-5 \dots$)
    3. 하단부의 **일반화된 공식** 도출이 핵심 ($N$값에 관계없이 성립해야 함).

## 3. 알고리즘 & 구현 테크닉 🛠️
- **이중 반복문 (Nested Loops)**: 행을 담당하는 바깥 루프와 공백/별을 찍는 안쪽 루프 2개로 구성.
- **수학적 규칙 적용**:
    - **상단**: 공백 $N-1-i$, 별 $2(i+1)-1$
    - **하단**: 공백 $i+1$, 별 $2N - 3 - 2i$
- **시간 복잡도**: $O(N^2)$ 
    - 이중 for문을 사용하며, 출력해야 할 별과 공백의 총개수가 $N^2$에 비례함. ($N \le 100$이므로 매우 충분)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **하드코딩 주의**: $N=5$일 때만 성립하는 식(예: `7 - 2*i`)을 사용하면 오답. 입력값 $N$을 포함한 일반항($2N - \dots$)을 세워야 함.
- **공백 처리**: 별 뒤쪽의 공백은 출력할 필요 없음 (출력 형식이 잘못되었습니다 오류 발생 가능). 별 앞쪽 공백만 정확히 계산하면 됨.
- **범위 설정**: 하단 반복문의 시작 조건과 종료 조건을 정확히 설정해야 함 (총 $N-1$줄).

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - 상단과 하단을 나누어 구현한 접근 방식이 명확함.
    - 특히 하단 별 개수를 구하는 과정에서 $N=5, 4$ 등의 케이스를 비교해 `2 * N - 3 - (i * 2)`라는 정확한 수식을 도출해낸 점이 훌륭함.
    - 변수 `N`, `i`, `j`, `k` 등 루프 변수 활용이 표준적임.

```cpp
#include <iostream>
using namespace std;

int main() {
	int N{};
	cin >> N;
	// 상단 삼각형 (1 ~ N번째 줄)
	for (int i{}; i < N; ++i) {
		for (int j{}; j < N - i - 1; ++j) {
			cout << ' ';
		}
		for (int k{}; k < (i + 1) * 2 - 1; ++k) {
			cout << '*';
		}
		cout << '\n';
	}
	// 하단 역삼각형 (N+1 ~ 2N-1번째 줄)
	for (int i{}; i < N - 1; ++i) {
		for (int j{}; j < i + 1; ++j) {
			cout << ' ';
		}
		// 핵심 공식 적용: 2*N - 3 에서 i가 늘어날 때마다 2개씩 감소
		for (int k{}; k < 2 * N - 3 - (i * 2); ++k) {
			cout << '*';
		}
		cout << '\n';
	}
}
```
