# 배열과 리스트 그리고 벡터

배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다.
배열의 값은 인덱스를 통해 참조할 수 있고, 선언한 자료형의 값만 저장할 수 있다.

리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.
노드란 컴퓨터 과학에서 값과 포인터를 쌍으로 갖는 기초 단위를 부르는 말이다.
리스트는 인덱스가 없어서 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.
다시 말해 값에 접근하는 속도가 느리다.
또한 배열과 다르게 크기를 별도로 지정하지 않아도 된다.

벡터는 C++ STL에 있는 자료구조 컨테이너 중 하나로, 기존의 배열과 같은 특징을 가지면서
단점을 보완한 동적 배열이다.
벡터는 동적으로 원소를 추가할 수 있다. 즉 크기가 자동으로 늘어난다.
개발자가 사용하기 편리하고 쉬우므로 코딩 테스트에서 많이 사용한다.

## 문제 001 - 숫자의 합 구하기
#백준 백준 11720

N의 범위가 1부터 100까지이므로, 배열이 필요하다.
먼저 문자열로 입력받은 뒤, 문자 배열로 변환한다.
문자 배열값을 순서대로 읽으면서 숫자형으로 변환하여 더해야 한다.
문자열을 숫자형으로 변경하려면 아스키 코드를 이해해야 한다.
아스키코드에서 같은 의미의 문자와 숫자의 코드값 차이는 48이다.
예를 들어 문자 '1'은 아스키코드 값이 49이므로, 숫자 1로 변환하려면 48을 빼거나 '0'을 빼야 한다.
```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	string numbers{};
	cin >> numbers;

	int sum{};
	for (int i{}; i < numbers.length(); ++i)
	{
		sum += numbers[i] - '0';
	}
	cout << sum << '\n';
}
```

## 문제 002 - 평균 구하기
#백준 백준 1546

```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	int arr[1000]{};
	long long max{};
	long long sum{};
	for (int i{}; i < N; ++i)
	{
		cin >> arr[i];
		if (max < arr[i])
			max = arr[i];
		sum += arr[i];
	}
	double result{ sum * 100.0 / max / N };
	cout << result << '\n';
}
```

점수를 1차원 배열에 저장하고,
최고 점수와 점수의 총합을 구한다.
이후 총합 x 100 / 최고 점수 / 과목수 를 결과값으로 계산한다.
# 04-2 구간 합

구간 합 알고리즘이란 배열의 특정 구간에 포함된 요소들의 합을 매우 빠르게 계산하기 위해 사용하는 기법이다.
코딩 테스트에서 배열의 크기가 크고, 구간 합을 구해야 하는 횟수가
많을 때 필수적으로 사용한다.
누적 합 배열을 미리 만들어두고, 단순 뺄셈 연산 한 번으로
원하는 구간의 합을 구해내는 알고리즘이다.
이렇게 하면,
기존 방식: 매번 더함 -> 시간 복잡도 O(N)
구간 합 방식: 미리 계산해두고 뺄셈만 함 -> 시간 복잡도 O(1)
예를 들어보자.
A 배열 10 20 30 40 50 이 있다고 가정하자.
1단계는 누적 합 배열 S를 만드는 것이다.
`S[i] = A[0]+ ... +A[i]`
S 10 30 60 100 150
2단계는 구간 합을 구하는 것이다.
`Sum(L, R) = S[R] - S[L-1]`
인덱스 1부터 3까지의 합을 구하고 싶다면?
`S[3] = 100`이고, `S[0] = 10`
결과적으로 100 - 10 = 90이 된다.
## 문제 003 - 구간 합 구하기 1
#백준 1196
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	long long N{};
	long long M{};
	cin >> N >> M;
	int S[100001]{};

	for (int i{ 1 }; i < N + 1; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] += S[i - 1] + temp;
	}
	for (int i{}; i < M; ++i)
	{
		int a{};
		int b{};
		cin >> a >> b;
		cout << S[b] - S[a - 1] << '\n';
	}
}
```
앞서 배운 구간 합 알고리즘을 그대로 적용해보는 문제였다.
## 문제 004 - 구간 합 구하기 2
#백준 11660
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N{}, M{};
	cin >> N >> M;
	vector<vector<int>>A(N + 1, vector<int>(N + 1, 0));
	vector<vector<int>>S(N + 1, vector<int>(N + 1, 0));

	for (int i{ 1 }; i <= N; ++i)
	{
		for (int j{ 1 }; j <= N; ++j)
		{
			cin >> A[i][j];
			S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j];
		}
	}

	for (int i{}; i < M; ++i)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		int result{ S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1] };
		cout << result << '\n';
	}
}
```
이차원 배열이 아닌 이차원 벡터를 사용했다. 
코테에서는 벡터를 많이 쓰기도 하고 실무도 마찬가지이니 벡터에 익숙해지는 것이 좋다.
먼저 이 문제를 풀기 위해서는 이차원 배열의 구간 합을 구하는 방법을 알고 있어야 한다.
누적 합 배열을 구하는 방법은, 위쪽 땅 가져오기, 왼쪽 땅 가져오기, 겹친 부분 버리기, 내 값 더하기 이다.
```
// S[i][j] 채우기
S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]; // 패턴: (위 + 왼쪽 - 대각선) + 나
```
다음으로 구간 합은 먼저 시작점과 끝점이 주어진다.
전체 - 위쪽 - 왼쪽 + 대각선이 공식이다.
누적 합 배열은 대각선이 중복돼서 빼고, 구간 합을 구할 때는 대각선이 두 번 빠져서 한 번 더한다.
```
// 1. 시작점(x1, y1)과 끝점(x2, y2)이 주어짐
// 2. 무조건 빼는 건 '시작점 - 1' 임!

int result = S[x2][y2]         // 1. 큰놈 (그대로)
           - S[x1-1][y2]       // 2. 위쪽 빼기 (x만 -1)
           - S[x2][y1-1]       // 3. 왼쪽 빼기 (y만 -1)
           + S[x1-1][y1-1];    // 4. 대각선 더하기 (둘 다 -1)
```
그리고 2차원 벡터 선언 구문에 대해서도 알고 있어야 한다.
`vector<vector<int>> S(N+1, vector<int>(N+1, 0));`
S라는 이름의 벡터를 선언했고, 이 벡터 안에는 또 다른 int 벡터들이 들어있다.
일단 세로(행)으로 N+1칸을 만들었다.
이후 각각의 칸마다 0으로 꽉 채운 N+1 길이의 벡터를 하나씩 넣어달라고 한 것이다.
결과적으로 가로로도 N+1 칸이 생기고, 모든 칸이 0이 된다.
## 문제 005 - 나머지 합 구하기
#백준 10986

**구간 합의 나머지가 0**이라는 것은, 해당 구간의 시작과 끝 누적 합의 나머지가 같다는 뜻이다. 
수식: `(S[j] - S[i]) % M == 0` ⟺ `S[j] % M == S[i] % M` 
따라서 복잡한 구간 합 계산을 **"같은 나머지 개수 세기"** 문제로 바꿀 수 있다.
- **조합 공식 (Combination)**: n개 중 2개를 순서 없이 뽑는 경우의 수 $${}_nC_2 = \frac{n(n-1)}{2}$$
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	vector<long long> S(N, 0);
	vector<long long> C(M, 0);
	long long answer{};
	cin >> S[0];

	for (int i{ 1 }; i < N; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] = S[i - 1] + temp;
	}

	for (int i{ 0 }; i < N; ++i)
	{
		int remainder = S[i] % M;
		if (remainder == 0)
			++answer;
		C[remainder]++;
	}

	for (int i{}; i < M; ++i)
	{
		if (C[i] > 1)
			answer += C[i] * (C[i] - 1) / 2;
	}
	cout << answer << '\n';
}
```
# 04-3 투 포인터
# 문제 006 - 연속된 자연수의 합 구하기(백준 2018)
## 1. 문제 정보
- **태그**: #투포인터 #수학 
- **난이도**: 실버 5
- **날짜**: 2025-12-16

## 2. 문제 요약
- 자연수 N이 주어졌을 때, 연속된 자연수의 합으로 N을 표현하는 방법의 수 구하기.
- 예: 15 -> 15, (7+8), (4+5+6), (1+2+3+4+5) => 총 4가지

## 3. 핵심 알고리즘: 투 포인터 (Two Pointers) ✌️
- **개념**: 시작점(`start_index`)과 끝점(`end_index`) 두 개의 포인터를 사용하여 구간의 합을 조절하는 방식.
- **동작 원리**:
    1. **Sum > N (값이 큼)**: 값을 줄여야 함 → `start_index`를 한 칸 오른쪽으로 이동 (앞의 값을 뺌).
    2. **Sum < N (값이 작음)**: 값을 늘려야 함 → `end_index`를 한 칸 오른쪽으로 이동 (뒤에 값을 더함).
    3. **Sum == N (정답)**: 카운트 증가 (`count++`) → 다음 경우를 찾기 위해 `end_index` 이동.

## 4. 시간 복잡도 분석 ⏳
- **단순 반복문 사용 시**: 이중 루프를 돌아야 하므로 $O(N^2)$에 가까워져 시간 초과 가능성 있음.
- **투 포인터 사용 시**: `start`와 `end`가 각각 N까지 최대 한 번씩만 이동하므로 $O(N)$으로 해결 가능. (매우 효율적)

## 5. 구현 포인트 / 주의사항 ⚠️
- **초기화**: `count`를 1로 시작했다. (N 자기 자신 하나인 경우를 미리 포함)
- **종료 조건**: `end_index`가 N이 될 때까지 반복한다.
- **인덱스 이동 순서**: `sum`에서 값을 먼저 빼고 인덱스를 올릴지, 인덱스를 올리고 값을 뺄지 순서를 헷갈리지 말자.
    - 내 코드 방식: `sum -= start_index; start_index++;` (현재 start 값을 빼고, 포인터 이동)

## 6. 코드 (내 풀이)
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int N{};
	cin >> N;
	int start_index{ 1 };
	int end_index{ 1 };
	int count{ 1 };
	int sum{ 1 };

	while (end_index != N)
	{
		if (sum == N)
		{
			count++;
			end_index++;
			sum += end_index;
		}
		else if (sum > N)
		{
			sum -= start_index;
			start_index++;
		}
		else
		{
			end_index++;
			sum += end_index;
		}
	}
	cout << count << '\n';
}
```
# 문제 007 - 주몽의 명령 (백준 1940)

## 1. 문제 정보
- **태그**: #투포인터 #정렬 
- **난이도**: 실버 4
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 고유한 재료 번호를 가진 $N$개의 재료 중, 두 재료의 번호 합이 $M$이 되는 경우의 수(갑옷 개수) 구하기.
- **핵심 발상**: 
    1. 무작위로 나열된 수들을 탐색하려면 $O(N^2)$이 걸리지만, **정렬(Sorting)** 을 하면 합의 크기를 예측할 수 있다.
    2. 양 끝에서 포인터를 좁혀오며 합을 조절하는 **투 포인터** 전략을 사용한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **정렬 (Sorting)**: 투 포인터를 사용하기 위한 전제 조건. 오름차순으로 정렬해야 `start` 포인터를 올렸을 때 합이 커지고, `end` 포인터를 내렸을 때 합이 작아짐을 보장할 수 있다.
- **투 포인터 (Two Pointers)**:
    - `start` (왼쪽 끝, 최솟값 방향)와 `end` (오른쪽 끝, 최댓값 방향)를 배치.
    - 두 수의 합이 $M$보다 작으면: 합을 키워야 하므로 `start++`
    - 두 수의 합이 $M$보다 크면: 합을 줄여야 하므로 `end--`
    - 두 수의 합이 $M$과 같으면: 찾았으므로 `count++`, 그리고 다음 탐색을 위해 `start++`, `end--` (재료는 고유하므로 둘 다 이동)
- **시간 복잡도**: $O(N \log N)$
    - 정렬에 $O(N \log N)$, 투 포인터 탐색에 $O(N)$ 소요.
    - $N$이 최대 15,000이므로 충분히 통과. (단순 이중 반복문 $O(N^2)$도 약 2.25억 연산이라 아슬아슬하게 통과할 수도 있지만, 투 포인터가 훨씬 효율적)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **정렬 누락**: 투 포인터 로직을 짤 때 가장 많이 하는 실수. 정렬되지 않은 상태에서는 인덱스 이동이 합의 증감을 보장하지 못함.
- **포인터 이동 조건**: 합이 $M$과 같을 때 `start`나 `end` 중 하나만 옮겨도 되지만, 문제 조건상 **고유한 번호**들이므로 중복된 값이 없어 둘 다 옮겨도 무방함 (`start++`, `end--`).
- **루프 종료 조건**: `while (i < j)`가 정확함. 재료 2개가 필요하므로 `i == j` (재료 1개)인 경우는 포함하면 안 됨.

## 5. 내 코드 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	// 입출력 속도 향상
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	
	// N개의 재료 입력받기
	vector<int> A(N, 0);
	for (int i{}; i < N; ++i) {
		cin >> A[i];
	}
	
	// [핵심] 투 포인터 사용을 위한 정렬
	sort(A.begin(), A.end());

	int i{};         // 시작 포인터 (왼쪽)
	int j{ N - 1 };  // 끝 포인터 (오른쪽)
	int count{};     // 갑옷 개수

	// 양 끝에서 좁혀오며 탐색
	while (i < j) {
		if (A[i] + A[j] > M) {
			j--; // 합이 크면 큰 수를 줄임
		}
		else if (A[i] + A[j] < M) {
			i++; // 합이 작으면 작은 수를 키움
		}
		else {
			// 합이 M인 경우
			count++;
			i++;
			j--;
		}
	}
	cout << count << '\n';
}
```
# 문제 008 - 좋은 수 구하기(백준 1253)

## 1. 문제 정보
- **태그**: #투포인터 #정렬 #알고리즘 
- **난이도**: 골드 4
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: $N$개의 수 중에서 **다른 두 수의 합**으로 나타낼 수 있는 수(GOOD)의 개수를 구하라.
- **핵심 발상**: 
    1. **정렬**: 투 포인터를 사용하기 위해 배열을 오름차순 정렬한다.
    2. **타겟 고정**: 판별할 수(`target = A[i]`) 하나를 고정해두고, 나머지 배열 범위에서 두 수의 합을 찾는다.
    3. **투 포인터**: `left`와 `right`를 양 끝에서 좁혀오며 합을 탐색한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **투 포인터 (Two Pointers)**: 
    - 배열이 정렬되어 있으므로, 두 수의 합이 `target`보다 작으면 `left`를 올리고, 크면 `right`를 내려서 탐색 범위를 좁힌다.
- **시간 복잡도**: $O(N^2)$
    - 정렬에 $O(N \log N)$이 소요된다.
    - 각 수(`N`개)마다 투 포인터 탐색($O(N)$)을 수행하므로 총 시간 복잡도는 $O(N^2)$이다.
    - $N$이 최대 2,000이므로 연산 횟수는 약 4백만 번. 2초 안에 충분히 통과 가능하다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **"다른 두 수"의 조건 (가장 중요한 포인트)**:
    - 합이 `target`과 같더라도, 더하는 두 수의 인덱스가 현재 `target`의 인덱스(`i`)와 같으면 안 된다.
    - 즉, 자기 자신을 합에 포함시키는 경우를 예외 처리해야 한다.
    - 예: `[0, 5]`에서 `5`를 만들 때 `0 + 5`는 값은 맞지만, `5`가 자기 자신이므로 불가능.
- **예외 처리 로직**:
    - `A[left] + A[right] == target`일 때 바로 카운트하지 말고, `left == i` 혹은 `right == i`인지 확인 후 포인터를 이동시켜야 한다.
- **자료형**:
    - 수의 범위가 절댓값 10억이므로, 두 수의 합은 20억을 넘을 수 있다. 안전하게 `long long`을 사용해야 한다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `long long`을 사용하여 오버플로우를 잘 방지했습니다.
    - `while`문 내부에서 `if (left == i)` 분기를 통해 자기 자신을 제외하는 로직이 아주 정확하게 구현되었습니다.
    - `cin.tie(NULL)`을 사용하여 입출력 속도를 최적화한 점도 좋습니다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N{};
	cin >> N;
	vector<long long> A(N, 0);
	for (int i{}; i < N; ++i) {
		cin >> A[i];
	}
	sort(A.begin(), A.end());

	int count{};
	for (int i{}; i < N; ++i) {
		int left{ 0 };
		int right{ N - 1 };
		long long target{ A[i] };

		while (left < right) {
			if (A[left] + A[right] == target) {
				// 정답 후보를 찾았으나, 자기 자신(i)을 포함하는지 확인해야 함
				if (left == i) {
					left++;
				}
				else if (right == i) {
					right--;
				}
				else {
					count++; // 서로 다른 두 수의 합이 맞음
					break;
				}
			}
			else if (A[left] + A[right] > target) {
				right--;
			}
			else {
				left++;
			}
		}
	}
	cout << count << '\n';
}
```
# 04-4 슬라이딩 윈도우
# 문제 009 - DNA 비밀번호(백준 12891)

## 1. 문제 정보
- **태그**: #슬라이딩윈도우 #문자열 #구현
- **난이도**: 실버 2
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 임의의 DNA 문자열에서 부분 문자열 길이 $P$만큼 잘랐을 때, 주어진 A, C, G, T의 최소 개수 조건을 만족하는 경우의 수 구하기.
- **핵심 발상**: 
    1. **윈도우 밀기 (Sliding Window)**: 부분 문자열을 매번 새로 만드는 게 아니라, 창문을 한 칸씩 옆으로 밀면서 **맨 앞의 문자는 빼고, 맨 뒤의 문자는 더하는** 방식 사용.
    2. **상태 업데이트 최소화**: 매번 4개의 문자를 다 세는 것이 아니라, 문자가 추가/제거될 때 **조건 만족 여부가 변하는 순간**에만 상태 변수(`checkSecret`)를 갱신함.



## 3. 알고리즘 & 구현 테크닉 🛠️
- **슬라이딩 윈도우 (Sliding Window)**
    - 매번 부분 문자열을 탐색하면 시간 복잡도가 $O(S \times P)$가 되어 시간 초과 발생 가능성 있음.
    - 슬라이딩 윈도우를 사용하면 **$O(S)$** 만에 해결 가능. (윈도우 이동 시 연산이 $O(1)$이기 때문)
- **최적화 테크닉**:
    - `checkSecret` 변수: 현재 4개의 문자 중 몇 종류가 최소 개수 조건을 만족하는지 저장.
    - `checkSecret == 4`일 때만 정답 카운트(`answer`) 증가.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 처리**: 
    - 윈도우가 이동할 때 `remove`하는 인덱스는 `i-1`, `add`하는 인덱스는 `i+P-1`.
    - 반복문 범위: `i`는 `1`부터 `S-P`까지 (마지막 윈도우 포함 `i <= S-P`).
- **조건 판단 로직 (매우 중요!)**:
    - 개수가 늘어날 때: `required`와 **딱 같아지는 순간**(`==`)에만 `checkSecret` 증가.
    - 개수가 줄어들 때: `required`보다 **막 작아지는 순간**(`current == required - 1`)에만 `checkSecret` 감소.
    - 단순히 `>=`나 `<`로만 처리하면 중복 카운팅 실수가 발생할 수 있음.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `add`와 `remove` 함수를 분리하여 메인 로직의 가독성을 높인 점이 매우 훌륭함.
    - 전역 변수를 활용해 함수 간 데이터 공유를 간편하게 처리함 (코딩 테스트 실전용).
    - `switch` 문에 `default` 케이스를 추가하여 예외 처리를 꼼꼼히 함.

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 전역 변수로 선언하여 함수들이 공유하도록 함
int required[4]{ 0 };
int current[4]{ 0 };
int checkSecret{}; // 조건을 만족하는 문자의 종류 개수

// 문자를 인덱스(0~3)로 변환하는 헬퍼 함수
int getIndex(char c) {
	switch (c) {
	case 'A': return 0;
	case 'C': return 1;
	case 'G': return 2;
	case 'T': return 3;
	default: return -1;
	}
}

// 문자 추가 로직: 조건 만족 시 checkSecret 증가
void add(char c) {
	int idx{ getIndex(c) };
	current[idx]++;
	if (required[idx] == current[idx]) { // 딱 같아지는 순간 체크!
		checkSecret++;
	}
}

// 문자 제거 로직: 조건 불만족 시 checkSecret 감소
void remove(char c) {
	int idx{ getIndex(c) };
	current[idx]--;
	if (current[idx] == required[idx] - 1) { // 막 부족해지는 순간 체크!
		checkSecret--;
	}
}

int main() {
	ios::sync_with_stdio(false); // 입출력 속도 향상 (권장)
	cin.tie(NULL);

	int S, P;
	cin >> S >> P;
	vector<char> DNA(S, '0');
	for (int i{}; i < S; ++i) {
		cin >> DNA[i];
	}
	for (int i{}; i < 4; ++i) {
		cin >> required[i];
	}

	int answer{};

	// 1. 첫 번째 윈도우 초기화 (0 ~ P-1)
	for (int i{}; i < P; ++i) {
		int idx{ getIndex(DNA[i]) };
		current[idx]++;
	}

	// 초기 윈도우 상태 검사
	for (int i{}; i < 4; ++i) {
		if (required[i] <= current[i]) {
			checkSecret++;
		}
	}
	
	if (checkSecret == 4)
		answer++;

	// 2. 슬라이딩 윈도우 (1 ~ S-P)
	for (int i{ 1 }; i <= S - P; ++i) {
		remove(DNA[i - 1]);       // 맨 앞 문자 제거
		add(DNA[i + P - 1]);      // 맨 뒤 문자 추가
		if (checkSecret == 4)     // 4개 조건 모두 만족 시 정답 증가
			answer++;
	}
	cout << answer << '\n';
}