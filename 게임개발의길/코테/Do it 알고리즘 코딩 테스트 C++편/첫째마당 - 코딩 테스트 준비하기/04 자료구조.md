# 배열과 리스트 그리고 벡터

배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다.
배열의 값은 인덱스를 통해 참조할 수 있고, 선언한 자료형의 값만 저장할 수 있다.

리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.
노드란 컴퓨터 과학에서 값과 포인터를 쌍으로 갖는 기초 단위를 부르는 말이다.
리스트는 인덱스가 없어서 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.
다시 말해 값에 접근하는 속도가 느리다.
또한 배열과 다르게 크기를 별도로 지정하지 않아도 된다.

벡터는 C++ STL에 있는 자료구조 컨테이너 중 하나로, 기존의 배열과 같은 특징을 가지면서
단점을 보완한 동적 배열이다.
벡터는 동적으로 원소를 추가할 수 있다. 즉 크기가 자동으로 늘어난다.
개발자가 사용하기 편리하고 쉬우므로 코딩 테스트에서 많이 사용한다.

## 문제 001 - 숫자의 합 구하기
#백준 백준 11720

N의 범위가 1부터 100까지이므로, 배열이 필요하다.
먼저 문자열로 입력받은 뒤, 문자 배열로 변환한다.
문자 배열값을 순서대로 읽으면서 숫자형으로 변환하여 더해야 한다.
문자열을 숫자형으로 변경하려면 아스키 코드를 이해해야 한다.
아스키코드에서 같은 의미의 문자와 숫자의 코드값 차이는 48이다.
예를 들어 문자 '1'은 아스키코드 값이 49이므로, 숫자 1로 변환하려면 48을 빼거나 '0'을 빼야 한다.
```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	string numbers{};
	cin >> numbers;

	int sum{};
	for (int i{}; i < numbers.length(); ++i)
	{
		sum += numbers[i] - '0';
	}
	cout << sum << '\n';
}
```

## 문제 002 - 평균 구하기
#백준 백준 1546

```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	int arr[1000]{};
	long long max{};
	long long sum{};
	for (int i{}; i < N; ++i)
	{
		cin >> arr[i];
		if (max < arr[i])
			max = arr[i];
		sum += arr[i];
	}
	double result{ sum * 100.0 / max / N };
	cout << result << '\n';
}
```

점수를 1차원 배열에 저장하고,
최고 점수와 점수의 총합을 구한다.
이후 총합 x 100 / 최고 점수 / 과목수 를 결과값으로 계산한다.
# 04-2 구간 합

구간 합 알고리즘이란 배열의 특정 구간에 포함된 요소들의 합을 매우 빠르게 계산하기 위해 사용하는 기법이다.
코딩 테스트에서 배열의 크기가 크고, 구간 합을 구해야 하는 횟수가
많을 때 필수적으로 사용한다.
누적 합 배열을 미리 만들어두고, 단순 뺄셈 연산 한 번으로
원하는 구간의 합을 구해내는 알고리즘이다.
이렇게 하면,
기존 방식: 매번 더함 -> 시간 복잡도 O(N)
구간 합 방식: 미리 계산해두고 뺄셈만 함 -> 시간 복잡도 O(1)
예를 들어보자.
A 배열 10 20 30 40 50 이 있다고 가정하자.
1단계는 누적 합 배열 S를 만드는 것이다.
`S[i] = A[0]+ ... +A[i]`
S 10 30 60 100 150
2단계는 구간 합을 구하는 것이다.
`Sum(L, R) = S[R] - S[L-1]`
인덱스 1부터 3까지의 합을 구하고 싶다면?
`S[3] = 100`이고, `S[0] = 10`
결과적으로 100 - 10 = 90이 된다.
## 문제 003 - 구간 합 구하기 1
#백준 1196
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	long long N{};
	long long M{};
	cin >> N >> M;
	int S[100001]{};

	for (int i{ 1 }; i < N + 1; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] += S[i - 1] + temp;
	}
	for (int i{}; i < M; ++i)
	{
		int a{};
		int b{};
		cin >> a >> b;
		cout << S[b] - S[a - 1] << '\n';
	}
}
```
앞서 배운 구간 합 알고리즘을 그대로 적용해보는 문제였다.
