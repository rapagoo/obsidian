# 배열과 리스트 그리고 벡터

배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다.
배열의 값은 인덱스를 통해 참조할 수 있고, 선언한 자료형의 값만 저장할 수 있다.

리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.
노드란 컴퓨터 과학에서 값과 포인터를 쌍으로 갖는 기초 단위를 부르는 말이다.
리스트는 인덱스가 없어서 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.
다시 말해 값에 접근하는 속도가 느리다.
또한 배열과 다르게 크기를 별도로 지정하지 않아도 된다.

벡터는 C++ STL에 있는 자료구조 컨테이너 중 하나로, 기존의 배열과 같은 특징을 가지면서
단점을 보완한 동적 배열이다.
벡터는 동적으로 원소를 추가할 수 있다. 즉 크기가 자동으로 늘어난다.
개발자가 사용하기 편리하고 쉬우므로 코딩 테스트에서 많이 사용한다.

## 문제 001 - 숫자의 합 구하기
#백준 백준 11720

N의 범위가 1부터 100까지이므로, 배열이 필요하다.
먼저 문자열로 입력받은 뒤, 문자 배열로 변환한다.
문자 배열값을 순서대로 읽으면서 숫자형으로 변환하여 더해야 한다.
문자열을 숫자형으로 변경하려면 아스키 코드를 이해해야 한다.
아스키코드에서 같은 의미의 문자와 숫자의 코드값 차이는 48이다.
예를 들어 문자 '1'은 아스키코드 값이 49이므로, 숫자 1로 변환하려면 48을 빼거나 '0'을 빼야 한다.
```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	string numbers{};
	cin >> numbers;

	int sum{};
	for (int i{}; i < numbers.length(); ++i)
	{
		sum += numbers[i] - '0';
	}
	cout << sum << '\n';
}
```

## 문제 002 - 평균 구하기
#백준 백준 1546

```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	int arr[1000]{};
	long long max{};
	long long sum{};
	for (int i{}; i < N; ++i)
	{
		cin >> arr[i];
		if (max < arr[i])
			max = arr[i];
		sum += arr[i];
	}
	double result{ sum * 100.0 / max / N };
	cout << result << '\n';
}
```

점수를 1차원 배열에 저장하고,
최고 점수와 점수의 총합을 구한다.
이후 총합 x 100 / 최고 점수 / 과목수 를 결과값으로 계산한다.
# 04-2 구간 합

구간 합 알고리즘이란 배열의 특정 구간에 포함된 요소들의 합을 매우 빠르게 계산하기 위해 사용하는 기법이다.
코딩 테스트에서 배열의 크기가 크고, 구간 합을 구해야 하는 횟수가
많을 때 필수적으로 사용한다.
누적 합 배열을 미리 만들어두고, 단순 뺄셈 연산 한 번으로
원하는 구간의 합을 구해내는 알고리즘이다.
이렇게 하면,
기존 방식: 매번 더함 -> 시간 복잡도 O(N)
구간 합 방식: 미리 계산해두고 뺄셈만 함 -> 시간 복잡도 O(1)
예를 들어보자.
A 배열 10 20 30 40 50 이 있다고 가정하자.
1단계는 누적 합 배열 S를 만드는 것이다.
`S[i] = A[0]+ ... +A[i]`
S 10 30 60 100 150
2단계는 구간 합을 구하는 것이다.
`Sum(L, R) = S[R] - S[L-1]`
인덱스 1부터 3까지의 합을 구하고 싶다면?
`S[3] = 100`이고, `S[0] = 10`
결과적으로 100 - 10 = 90이 된다.
## 문제 003 - 구간 합 구하기 1
#백준 1196
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	long long N{};
	long long M{};
	cin >> N >> M;
	int S[100001]{};

	for (int i{ 1 }; i < N + 1; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] += S[i - 1] + temp;
	}
	for (int i{}; i < M; ++i)
	{
		int a{};
		int b{};
		cin >> a >> b;
		cout << S[b] - S[a - 1] << '\n';
	}
}
```
앞서 배운 구간 합 알고리즘을 그대로 적용해보는 문제였다.
## 문제 004 - 구간 합 구하기 2
#백준 11660
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N{}, M{};
	cin >> N >> M;
	vector<vector<int>>A(N + 1, vector<int>(N + 1, 0));
	vector<vector<int>>S(N + 1, vector<int>(N + 1, 0));

	for (int i{ 1 }; i <= N; ++i)
	{
		for (int j{ 1 }; j <= N; ++j)
		{
			cin >> A[i][j];
			S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j];
		}
	}

	for (int i{}; i < M; ++i)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		int result{ S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1] };
		cout << result << '\n';
	}
}
```
이차원 배열이 아닌 이차원 벡터를 사용했다. 
코테에서는 벡터를 많이 쓰기도 하고 실무도 마찬가지이니 벡터에 익숙해지는 것이 좋다.
먼저 이 문제를 풀기 위해서는 이차원 배열의 구간 합을 구하는 방법을 알고 있어야 한다.
누적 합 배열을 구하는 방법은, 위쪽 땅 가져오기, 왼쪽 땅 가져오기, 겹친 부분 버리기, 내 값 더하기 이다.
```
// S[i][j] 채우기
S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]; // 패턴: (위 + 왼쪽 - 대각선) + 나
```
다음으로 구간 합은 먼저 시작점과 끝점이 주어진다.
전체 - 위쪽 - 왼쪽 + 대각선이 공식이다.
누적 합 배열은 대각선이 중복돼서 빼고, 구간 합을 구할 때는 대각선이 두 번 빠져서 한 번 더한다.
```
// 1. 시작점(x1, y1)과 끝점(x2, y2)이 주어짐
// 2. 무조건 빼는 건 '시작점 - 1' 임!

int result = S[x2][y2]         // 1. 큰놈 (그대로)
           - S[x1-1][y2]       // 2. 위쪽 빼기 (x만 -1)
           - S[x2][y1-1]       // 3. 왼쪽 빼기 (y만 -1)
           + S[x1-1][y1-1];    // 4. 대각선 더하기 (둘 다 -1)
```
그리고 2차원 벡터 선언 구문에 대해서도 알고 있어야 한다.
`vector<vector<int>> S(N+1, vector<int>(N+1, 0));`
S라는 이름의 벡터를 선언했고, 이 벡터 안에는 또 다른 int 벡터들이 들어있다.
일단 세로(행)으로 N+1칸을 만들었다.
이후 각각의 칸마다 0으로 꽉 채운 N+1 길이의 벡터를 하나씩 넣어달라고 한 것이다.
결과적으로 가로로도 N+1 칸이 생기고, 모든 칸이 0이 된다.
## 문제 005 - 나머지 합 구하기
#백준 10986

**구간 합의 나머지가 0**이라는 것은, 해당 구간의 시작과 끝 누적 합의 나머지가 같다는 뜻이다. 
수식: `(S[j] - S[i]) % M == 0` ⟺ `S[j] % M == S[i] % M` 
따라서 복잡한 구간 합 계산을 **"같은 나머지 개수 세기"** 문제로 바꿀 수 있다.
- **조합 공식 (Combination)**: n개 중 2개를 순서 없이 뽑는 경우의 수 $${}_nC_2 = \frac{n(n-1)}{2}$$
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	vector<long long> S(N, 0);
	vector<long long> C(M, 0);
	long long answer{};
	cin >> S[0];

	for (int i{ 1 }; i < N; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] = S[i - 1] + temp;
	}

	for (int i{ 0 }; i < N; ++i)
	{
		int remainder = S[i] % M;
		if (remainder == 0)
			++answer;
		C[remainder]++;
	}

	for (int i{}; i < M; ++i)
	{
		if (C[i] > 1)
			answer += C[i] * (C[i] - 1) / 2;
	}
	cout << answer << '\n';
}
```
# 04-3 투 포인터
# 문제 006 - 연속된 자연수의 합 구하기

## 1. 문제 정보
- **태그**: #투포인터 #수학 
- **난이도**: 실버 5
- **날짜**: 2025-12-16

## 2. 문제 요약
- 자연수 N이 주어졌을 때, 연속된 자연수의 합으로 N을 표현하는 방법의 수 구하기.
- 예: 15 -> 15, (7+8), (4+5+6), (1+2+3+4+5) => 총 4가지

## 3. 핵심 알고리즘: 투 포인터 (Two Pointers) ✌️
- **개념**: 시작점(`start_index`)과 끝점(`end_index`) 두 개의 포인터를 사용하여 구간의 합을 조절하는 방식.
- **동작 원리**:
    1. **Sum > N (값이 큼)**: 값을 줄여야 함 → `start_index`를 한 칸 오른쪽으로 이동 (앞의 값을 뺌).
    2. **Sum < N (값이 작음)**: 값을 늘려야 함 → `end_index`를 한 칸 오른쪽으로 이동 (뒤에 값을 더함).
    3. **Sum == N (정답)**: 카운트 증가 (`count++`) → 다음 경우를 찾기 위해 `end_index` 이동.

## 4. 시간 복잡도 분석 ⏳
- **단순 반복문 사용 시**: 이중 루프를 돌아야 하므로 $O(N^2)$에 가까워져 시간 초과 가능성 있음.
- **투 포인터 사용 시**: `start`와 `end`가 각각 N까지 최대 한 번씩만 이동하므로 $O(N)$으로 해결 가능. (매우 효율적)

## 5. 구현 포인트 / 주의사항 ⚠️
- **초기화**: `count`를 1로 시작했다. (N 자기 자신 하나인 경우를 미리 포함)
- **종료 조건**: `end_index`가 N이 될 때까지 반복한다.
- **인덱스 이동 순서**: `sum`에서 값을 먼저 빼고 인덱스를 올릴지, 인덱스를 올리고 값을 뺄지 순서를 헷갈리지 말자.
    - 내 코드 방식: `sum -= start_index; start_index++;` (현재 start 값을 빼고, 포인터 이동)

## 6. 코드 (내 풀이)
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int N{};
	cin >> N;
	int start_index{ 1 };
	int end_index{ 1 };
	int count{ 1 };
	int sum{ 1 };

	while (end_index != N)
	{
		if (sum == N)
		{
			count++;
			end_index++;
			sum += end_index;
		}
		else if (sum > N)
		{
			sum -= start_index;
			start_index++;
		}
		else
		{
			end_index++;
			sum += end_index;
		}
	}
	cout << count << '\n';
}
```
