# 배열과 리스트 그리고 벡터

배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다.
배열의 값은 인덱스를 통해 참조할 수 있고, 선언한 자료형의 값만 저장할 수 있다.

리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.
노드란 컴퓨터 과학에서 값과 포인터를 쌍으로 갖는 기초 단위를 부르는 말이다.
리스트는 인덱스가 없어서 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다.
다시 말해 값에 접근하는 속도가 느리다.
또한 배열과 다르게 크기를 별도로 지정하지 않아도 된다.

벡터는 C++ STL에 있는 자료구조 컨테이너 중 하나로, 기존의 배열과 같은 특징을 가지면서
단점을 보완한 동적 배열이다.
벡터는 동적으로 원소를 추가할 수 있다. 즉 크기가 자동으로 늘어난다.
개발자가 사용하기 편리하고 쉬우므로 코딩 테스트에서 많이 사용한다.

## 문제 001 - 숫자의 합 구하기
#백준 백준 11720

N의 범위가 1부터 100까지이므로, 배열이 필요하다.
먼저 문자열로 입력받은 뒤, 문자 배열로 변환한다.
문자 배열값을 순서대로 읽으면서 숫자형으로 변환하여 더해야 한다.
문자열을 숫자형으로 변경하려면 아스키 코드를 이해해야 한다.
아스키코드에서 같은 의미의 문자와 숫자의 코드값 차이는 48이다.
예를 들어 문자 '1'은 아스키코드 값이 49이므로, 숫자 1로 변환하려면 48을 빼거나 '0'을 빼야 한다.
```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	string numbers{};
	cin >> numbers;

	int sum{};
	for (int i{}; i < numbers.length(); ++i)
	{
		sum += numbers[i] - '0';
	}
	cout << sum << '\n';
}
```

## 문제 002 - 평균 구하기
#백준 백준 1546

```cpp
#include <iostream>
using namespace std;

int main()
{
	int N{};
	cin >> N;
	int arr[1000]{};
	long long max{};
	long long sum{};
	for (int i{}; i < N; ++i)
	{
		cin >> arr[i];
		if (max < arr[i])
			max = arr[i];
		sum += arr[i];
	}
	double result{ sum * 100.0 / max / N };
	cout << result << '\n';
}
```

점수를 1차원 배열에 저장하고,
최고 점수와 점수의 총합을 구한다.
이후 총합 x 100 / 최고 점수 / 과목수 를 결과값으로 계산한다.
# 04-2 구간 합

구간 합 알고리즘이란 배열의 특정 구간에 포함된 요소들의 합을 매우 빠르게 계산하기 위해 사용하는 기법이다.
코딩 테스트에서 배열의 크기가 크고, 구간 합을 구해야 하는 횟수가
많을 때 필수적으로 사용한다.
누적 합 배열을 미리 만들어두고, 단순 뺄셈 연산 한 번으로
원하는 구간의 합을 구해내는 알고리즘이다.
이렇게 하면,
기존 방식: 매번 더함 -> 시간 복잡도 O(N)
구간 합 방식: 미리 계산해두고 뺄셈만 함 -> 시간 복잡도 O(1)
예를 들어보자.
A 배열 10 20 30 40 50 이 있다고 가정하자.
1단계는 누적 합 배열 S를 만드는 것이다.
`S[i] = A[0]+ ... +A[i]`
S 10 30 60 100 150
2단계는 구간 합을 구하는 것이다.
`Sum(L, R) = S[R] - S[L-1]`
인덱스 1부터 3까지의 합을 구하고 싶다면?
`S[3] = 100`이고, `S[0] = 10`
결과적으로 100 - 10 = 90이 된다.
## 문제 003 - 구간 합 구하기 1
#백준 1196
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	long long N{};
	long long M{};
	cin >> N >> M;
	int S[100001]{};

	for (int i{ 1 }; i < N + 1; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] += S[i - 1] + temp;
	}
	for (int i{}; i < M; ++i)
	{
		int a{};
		int b{};
		cin >> a >> b;
		cout << S[b] - S[a - 1] << '\n';
	}
}
```
앞서 배운 구간 합 알고리즘을 그대로 적용해보는 문제였다.
## 문제 004 - 구간 합 구하기 2
#백준 11660
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N{}, M{};
	cin >> N >> M;
	vector<vector<int>>A(N + 1, vector<int>(N + 1, 0));
	vector<vector<int>>S(N + 1, vector<int>(N + 1, 0));

	for (int i{ 1 }; i <= N; ++i)
	{
		for (int j{ 1 }; j <= N; ++j)
		{
			cin >> A[i][j];
			S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + A[i][j];
		}
	}

	for (int i{}; i < M; ++i)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		int result{ S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1] };
		cout << result << '\n';
	}
}
```
이차원 배열이 아닌 이차원 벡터를 사용했다. 
코테에서는 벡터를 많이 쓰기도 하고 실무도 마찬가지이니 벡터에 익숙해지는 것이 좋다.
먼저 이 문제를 풀기 위해서는 이차원 배열의 구간 합을 구하는 방법을 알고 있어야 한다.
누적 합 배열을 구하는 방법은, 위쪽 땅 가져오기, 왼쪽 땅 가져오기, 겹친 부분 버리기, 내 값 더하기 이다.
```
// S[i][j] 채우기
S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]; // 패턴: (위 + 왼쪽 - 대각선) + 나
```
다음으로 구간 합은 먼저 시작점과 끝점이 주어진다.
전체 - 위쪽 - 왼쪽 + 대각선이 공식이다.
누적 합 배열은 대각선이 중복돼서 빼고, 구간 합을 구할 때는 대각선이 두 번 빠져서 한 번 더한다.
```
// 1. 시작점(x1, y1)과 끝점(x2, y2)이 주어짐
// 2. 무조건 빼는 건 '시작점 - 1' 임!

int result = S[x2][y2]         // 1. 큰놈 (그대로)
           - S[x1-1][y2]       // 2. 위쪽 빼기 (x만 -1)
           - S[x2][y1-1]       // 3. 왼쪽 빼기 (y만 -1)
           + S[x1-1][y1-1];    // 4. 대각선 더하기 (둘 다 -1)
```
그리고 2차원 벡터 선언 구문에 대해서도 알고 있어야 한다.
`vector<vector<int>> S(N+1, vector<int>(N+1, 0));`
S라는 이름의 벡터를 선언했고, 이 벡터 안에는 또 다른 int 벡터들이 들어있다.
일단 세로(행)으로 N+1칸을 만들었다.
이후 각각의 칸마다 0으로 꽉 채운 N+1 길이의 벡터를 하나씩 넣어달라고 한 것이다.
결과적으로 가로로도 N+1 칸이 생기고, 모든 칸이 0이 된다.
## 문제 005 - 나머지 합 구하기
#백준 10986

**구간 합의 나머지가 0**이라는 것은, 해당 구간의 시작과 끝 누적 합의 나머지가 같다는 뜻이다. 
수식: `(S[j] - S[i]) % M == 0` ⟺ `S[j] % M == S[i] % M` 
따라서 복잡한 구간 합 계산을 **"같은 나머지 개수 세기"** 문제로 바꿀 수 있다.
- **조합 공식 (Combination)**: n개 중 2개를 순서 없이 뽑는 경우의 수 $${}_nC_2 = \frac{n(n-1)}{2}$$
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	vector<long long> S(N, 0);
	vector<long long> C(M, 0);
	long long answer{};
	cin >> S[0];

	for (int i{ 1 }; i < N; ++i)
	{
		int temp{};
		cin >> temp;
		S[i] = S[i - 1] + temp;
	}

	for (int i{ 0 }; i < N; ++i)
	{
		int remainder = S[i] % M;
		if (remainder == 0)
			++answer;
		C[remainder]++;
	}

	for (int i{}; i < M; ++i)
	{
		if (C[i] > 1)
			answer += C[i] * (C[i] - 1) / 2;
	}
	cout << answer << '\n';
}
```
# 04-3 투 포인터
# 문제 006 - 연속된 자연수의 합 구하기(백준 2018)
## 1. 문제 정보
- **태그**: #투포인터 #수학 
- **난이도**: 실버 5
- **날짜**: 2025-12-16

## 2. 문제 요약
- 자연수 N이 주어졌을 때, 연속된 자연수의 합으로 N을 표현하는 방법의 수 구하기.
- 예: 15 -> 15, (7+8), (4+5+6), (1+2+3+4+5) => 총 4가지

## 3. 핵심 알고리즘: 투 포인터 (Two Pointers) ✌️
- **개념**: 시작점(`start_index`)과 끝점(`end_index`) 두 개의 포인터를 사용하여 구간의 합을 조절하는 방식.
- **동작 원리**:
    1. **Sum > N (값이 큼)**: 값을 줄여야 함 → `start_index`를 한 칸 오른쪽으로 이동 (앞의 값을 뺌).
    2. **Sum < N (값이 작음)**: 값을 늘려야 함 → `end_index`를 한 칸 오른쪽으로 이동 (뒤에 값을 더함).
    3. **Sum == N (정답)**: 카운트 증가 (`count++`) → 다음 경우를 찾기 위해 `end_index` 이동.

## 4. 시간 복잡도 분석 ⏳
- **단순 반복문 사용 시**: 이중 루프를 돌아야 하므로 $O(N^2)$에 가까워져 시간 초과 가능성 있음.
- **투 포인터 사용 시**: `start`와 `end`가 각각 N까지 최대 한 번씩만 이동하므로 $O(N)$으로 해결 가능. (매우 효율적)

## 5. 구현 포인트 / 주의사항 ⚠️
- **초기화**: `count`를 1로 시작했다. (N 자기 자신 하나인 경우를 미리 포함)
- **종료 조건**: `end_index`가 N이 될 때까지 반복한다.
- **인덱스 이동 순서**: `sum`에서 값을 먼저 빼고 인덱스를 올릴지, 인덱스를 올리고 값을 뺄지 순서를 헷갈리지 말자.
    - 내 코드 방식: `sum -= start_index; start_index++;` (현재 start 값을 빼고, 포인터 이동)

## 6. 코드 (내 풀이)
```cpp
#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int N{};
	cin >> N;
	int start_index{ 1 };
	int end_index{ 1 };
	int count{ 1 };
	int sum{ 1 };

	while (end_index != N)
	{
		if (sum == N)
		{
			count++;
			end_index++;
			sum += end_index;
		}
		else if (sum > N)
		{
			sum -= start_index;
			start_index++;
		}
		else
		{
			end_index++;
			sum += end_index;
		}
	}
	cout << count << '\n';
}
```
# 문제 007 - 주몽의 명령 (백준 1940)

## 1. 문제 정보
- **태그**: #투포인터 #정렬 
- **난이도**: 실버 4
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 고유한 재료 번호를 가진 $N$개의 재료 중, 두 재료의 번호 합이 $M$이 되는 경우의 수(갑옷 개수) 구하기.
- **핵심 발상**: 
    1. 무작위로 나열된 수들을 탐색하려면 $O(N^2)$이 걸리지만, **정렬(Sorting)** 을 하면 합의 크기를 예측할 수 있다.
    2. 양 끝에서 포인터를 좁혀오며 합을 조절하는 **투 포인터** 전략을 사용한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **정렬 (Sorting)**: 투 포인터를 사용하기 위한 전제 조건. 오름차순으로 정렬해야 `start` 포인터를 올렸을 때 합이 커지고, `end` 포인터를 내렸을 때 합이 작아짐을 보장할 수 있다.
- **투 포인터 (Two Pointers)**:
    - `start` (왼쪽 끝, 최솟값 방향)와 `end` (오른쪽 끝, 최댓값 방향)를 배치.
    - 두 수의 합이 $M$보다 작으면: 합을 키워야 하므로 `start++`
    - 두 수의 합이 $M$보다 크면: 합을 줄여야 하므로 `end--`
    - 두 수의 합이 $M$과 같으면: 찾았으므로 `count++`, 그리고 다음 탐색을 위해 `start++`, `end--` (재료는 고유하므로 둘 다 이동)
- **시간 복잡도**: $O(N \log N)$
    - 정렬에 $O(N \log N)$, 투 포인터 탐색에 $O(N)$ 소요.
    - $N$이 최대 15,000이므로 충분히 통과. (단순 이중 반복문 $O(N^2)$도 약 2.25억 연산이라 아슬아슬하게 통과할 수도 있지만, 투 포인터가 훨씬 효율적)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **정렬 누락**: 투 포인터 로직을 짤 때 가장 많이 하는 실수. 정렬되지 않은 상태에서는 인덱스 이동이 합의 증감을 보장하지 못함.
- **포인터 이동 조건**: 합이 $M$과 같을 때 `start`나 `end` 중 하나만 옮겨도 되지만, 문제 조건상 **고유한 번호**들이므로 중복된 값이 없어 둘 다 옮겨도 무방함 (`start++`, `end--`).
- **루프 종료 조건**: `while (i < j)`가 정확함. 재료 2개가 필요하므로 `i == j` (재료 1개)인 경우는 포함하면 안 됨.

## 5. 내 코드 
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	// 입출력 속도 향상
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N, M;
	cin >> N >> M;
	
	// N개의 재료 입력받기
	vector<int> A(N, 0);
	for (int i{}; i < N; ++i) {
		cin >> A[i];
	}
	
	// [핵심] 투 포인터 사용을 위한 정렬
	sort(A.begin(), A.end());

	int i{};         // 시작 포인터 (왼쪽)
	int j{ N - 1 };  // 끝 포인터 (오른쪽)
	int count{};     // 갑옷 개수

	// 양 끝에서 좁혀오며 탐색
	while (i < j) {
		if (A[i] + A[j] > M) {
			j--; // 합이 크면 큰 수를 줄임
		}
		else if (A[i] + A[j] < M) {
			i++; // 합이 작으면 작은 수를 키움
		}
		else {
			// 합이 M인 경우
			count++;
			i++;
			j--;
		}
	}
	cout << count << '\n';
}
```
# 문제 008 - 좋은 수 구하기(백준 1253)

## 1. 문제 정보
- **태그**: #투포인터 #정렬 #알고리즘 
- **난이도**: 골드 4
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: $N$개의 수 중에서 **다른 두 수의 합**으로 나타낼 수 있는 수(GOOD)의 개수를 구하라.
- **핵심 발상**: 
    1. **정렬**: 투 포인터를 사용하기 위해 배열을 오름차순 정렬한다.
    2. **타겟 고정**: 판별할 수(`target = A[i]`) 하나를 고정해두고, 나머지 배열 범위에서 두 수의 합을 찾는다.
    3. **투 포인터**: `left`와 `right`를 양 끝에서 좁혀오며 합을 탐색한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **투 포인터 (Two Pointers)**: 
    - 배열이 정렬되어 있으므로, 두 수의 합이 `target`보다 작으면 `left`를 올리고, 크면 `right`를 내려서 탐색 범위를 좁힌다.
- **시간 복잡도**: $O(N^2)$
    - 정렬에 $O(N \log N)$이 소요된다.
    - 각 수(`N`개)마다 투 포인터 탐색($O(N)$)을 수행하므로 총 시간 복잡도는 $O(N^2)$이다.
    - $N$이 최대 2,000이므로 연산 횟수는 약 4백만 번. 2초 안에 충분히 통과 가능하다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **"다른 두 수"의 조건 (가장 중요한 포인트)**:
    - 합이 `target`과 같더라도, 더하는 두 수의 인덱스가 현재 `target`의 인덱스(`i`)와 같으면 안 된다.
    - 즉, 자기 자신을 합에 포함시키는 경우를 예외 처리해야 한다.
    - 예: `[0, 5]`에서 `5`를 만들 때 `0 + 5`는 값은 맞지만, `5`가 자기 자신이므로 불가능.
- **예외 처리 로직**:
    - `A[left] + A[right] == target`일 때 바로 카운트하지 말고, `left == i` 혹은 `right == i`인지 확인 후 포인터를 이동시켜야 한다.
- **자료형**:
    - 수의 범위가 절댓값 10억이므로, 두 수의 합은 20억을 넘을 수 있다. 안전하게 `long long`을 사용해야 한다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `long long`을 사용하여 오버플로우를 잘 방지했습니다.
    - `while`문 내부에서 `if (left == i)` 분기를 통해 자기 자신을 제외하는 로직이 아주 정확하게 구현되었습니다.
    - `cin.tie(NULL)`을 사용하여 입출력 속도를 최적화한 점도 좋습니다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int N{};
	cin >> N;
	vector<long long> A(N, 0);
	for (int i{}; i < N; ++i) {
		cin >> A[i];
	}
	sort(A.begin(), A.end());

	int count{};
	for (int i{}; i < N; ++i) {
		int left{ 0 };
		int right{ N - 1 };
		long long target{ A[i] };

		while (left < right) {
			if (A[left] + A[right] == target) {
				// 정답 후보를 찾았으나, 자기 자신(i)을 포함하는지 확인해야 함
				if (left == i) {
					left++;
				}
				else if (right == i) {
					right--;
				}
				else {
					count++; // 서로 다른 두 수의 합이 맞음
					break;
				}
			}
			else if (A[left] + A[right] > target) {
				right--;
			}
			else {
				left++;
			}
		}
	}
	cout << count << '\n';
}
```
# 04-4 슬라이딩 윈도우
# 문제 009 - DNA 비밀번호(백준 12891)

## 1. 문제 정보
- **태그**: #슬라이딩윈도우 #문자열 #구현
- **난이도**: 실버 2
- **날짜**: 2025-12-17

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 임의의 DNA 문자열에서 부분 문자열 길이 $P$만큼 잘랐을 때, 주어진 A, C, G, T의 최소 개수 조건을 만족하는 경우의 수 구하기.
- **핵심 발상**: 
    1. **윈도우 밀기 (Sliding Window)**: 부분 문자열을 매번 새로 만드는 게 아니라, 창문을 한 칸씩 옆으로 밀면서 **맨 앞의 문자는 빼고, 맨 뒤의 문자는 더하는** 방식 사용.
    2. **상태 업데이트 최소화**: 매번 4개의 문자를 다 세는 것이 아니라, 문자가 추가/제거될 때 **조건 만족 여부가 변하는 순간**에만 상태 변수(`checkSecret`)를 갱신함.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **슬라이딩 윈도우 (Sliding Window)**
    - 매번 부분 문자열을 탐색하면 시간 복잡도가 $O(S \times P)$가 되어 시간 초과 발생 가능성 있음.
    - 슬라이딩 윈도우를 사용하면 **$O(S)$** 만에 해결 가능. (윈도우 이동 시 연산이 $O(1)$이기 때문)
- **최적화 테크닉**:
    - `checkSecret` 변수: 현재 4개의 문자 중 몇 종류가 최소 개수 조건을 만족하는지 저장.
    - `checkSecret == 4`일 때만 정답 카운트(`answer`) 증가.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **인덱스 처리**: 
    - 윈도우가 이동할 때 `remove`하는 인덱스는 `i-1`, `add`하는 인덱스는 `i+P-1`.
    - 반복문 범위: `i`는 `1`부터 `S-P`까지 (마지막 윈도우 포함 `i <= S-P`).
- **조건 판단 로직 (매우 중요!)**:
    - 개수가 늘어날 때: `required`와 **딱 같아지는 순간**(`==`)에만 `checkSecret` 증가.
    - 개수가 줄어들 때: `required`보다 **막 작아지는 순간**(`current == required - 1`)에만 `checkSecret` 감소.
    - 단순히 `>=`나 `<`로만 처리하면 중복 카운팅 실수가 발생할 수 있음.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `add`와 `remove` 함수를 분리하여 메인 로직의 가독성을 높인 점이 매우 훌륭함.
    - 전역 변수를 활용해 함수 간 데이터 공유를 간편하게 처리함 (코딩 테스트 실전용).
    - `switch` 문에 `default` 케이스를 추가하여 예외 처리를 꼼꼼히 함.

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 전역 변수로 선언하여 함수들이 공유하도록 함
int required[4]{ 0 };
int current[4]{ 0 };
int checkSecret{}; // 조건을 만족하는 문자의 종류 개수

// 문자를 인덱스(0~3)로 변환하는 헬퍼 함수
int getIndex(char c) {
	switch (c) {
	case 'A': return 0;
	case 'C': return 1;
	case 'G': return 2;
	case 'T': return 3;
	default: return -1;
	}
}

// 문자 추가 로직: 조건 만족 시 checkSecret 증가
void add(char c) {
	int idx{ getIndex(c) };
	current[idx]++;
	if (required[idx] == current[idx]) { // 딱 같아지는 순간 체크!
		checkSecret++;
	}
}

// 문자 제거 로직: 조건 불만족 시 checkSecret 감소
void remove(char c) {
	int idx{ getIndex(c) };
	current[idx]--;
	if (current[idx] == required[idx] - 1) { // 막 부족해지는 순간 체크!
		checkSecret--;
	}
}

int main() {
	ios::sync_with_stdio(false); // 입출력 속도 향상 (권장)
	cin.tie(NULL);

	int S, P;
	cin >> S >> P;
	vector<char> DNA(S, '0');
	for (int i{}; i < S; ++i) {
		cin >> DNA[i];
	}
	for (int i{}; i < 4; ++i) {
		cin >> required[i];
	}

	int answer{};

	// 1. 첫 번째 윈도우 초기화 (0 ~ P-1)
	for (int i{}; i < P; ++i) {
		int idx{ getIndex(DNA[i]) };
		current[idx]++;
	}

	// 초기 윈도우 상태 검사
	for (int i{}; i < 4; ++i) {
		if (required[i] <= current[i]) {
			checkSecret++;
		}
	}
	
	if (checkSecret == 4)
		answer++;

	// 2. 슬라이딩 윈도우 (1 ~ S-P)
	for (int i{ 1 }; i <= S - P; ++i) {
		remove(DNA[i - 1]);       // 맨 앞 문자 제거
		add(DNA[i + P - 1]);      // 맨 뒤 문자 추가
		if (checkSecret == 4)     // 4개 조건 모두 만족 시 정답 증가
			answer++;
	}
	cout << answer << '\n';
}
```
# 문제 010 - 최솟값 찾기(백준 11003)

## 1. 문제 정보
- **태그**: #슬라이딩윈도우 #덱 #자료구조 #우선순위큐
- **난이도**: 플래티넘 V
- **날짜**: 2025-12-20

## 2. 문제 요약 & 핵심 아이디어 💡
- $N$개의 수 $A_1, A_2, ..., A_N$이 주어질 때, $i-L+1$부터 $i$까지의 범위 내에서 최솟값 $D_i$를 구하는 문제.
- **핵심 발상**: 단순히 매번 정렬하거나 순회하면 $O(NL)$로 시간 초과 발생. **덱(Deque)을 사용하여 내부를 항상 오름차순으로 유지(Monotonic Queue)**하는 것이 핵심.
  1. 새로운 값이 들어올 때, 그 값보다 큰 덱의 뒤쪽 원소들은 "앞으로 최솟값이 될 가능성이 없으므로" 제거한다.
  2. 윈도우 범위를 벗어난 앞쪽 원소는 제거한다.
  3. 덱의 맨 앞(`front`)이 항상 현재 윈도우의 최솟값이다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **슬라이딩 윈도우 + 덱(Deque)**: 윈도우를 밀면서 필요한 후보군만 덱에 남기는 방식.
- **시간 복잡도**: $O(N)$
  - 겉보기엔 이중 반복문처럼 보이지만, 모든 원소는 덱에 **정확히 한 번 들어가고(`push`), 최대 한 번 나옴(`pop`)**. 따라서 선형 시간 내에 해결 가능함.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **입출력 속도**: $N$과 $L$이 최대 5,000,000이다. $O(N)$ 로직이라도 C++ 표준 입출력(`cin`, `cout`)을 그냥 사용하면 시간 초과(TLE)가 발생한다. 반드시 입출력 최적화가 필요함.
- **인덱스 처리**: 문제에서는 인덱스가 1부터 시작한다고 설명하지만, 코드 구현 시 0부터 시작하는 것이 일반적이다. 윈도우 범위를 벗어났는지 체크하는 조건식 `i - L` 계산에 유의.
- **자료형**: 값의 범위가 `int` 범위 내인지 확인 필요(이 문제는 `int`로 충분).

## 5. 내 코드 & 피드백
- **코드 리뷰**:
  - 👍 **로직 구현**: 덱을 이용해 오름차순을 유지하고, 범위를 벗어난 원소를 제거하는 로직이 아주 깔끔하고 정확합니다.
  - ❗ **치명적인 개선점 (시간 초과 주의)**: 앞서 언급했듯, 이 문제는 500만 개의 입출력을 처리해야 합니다. `main` 함수 시작 부분에 `std::ios::sync_with_stdio(false); std::cin.tie(NULL);`를 넣지 않으면 정답 로직이라도 시간 초과를 받게 됩니다.
  - **개행 문자**: 반복문 안에서 `std::endl` 대신 `\n`을 쓰거나 공백을 쓰는 것이 좋습니다. (현재 코드는 공백을 쓰고 있어 아주 좋습니다.)

```cpp
#include <iostream>
#include <deque>

int main() {
    // [피드백 반영] 대량의 데이터 처리를 위한 필수 입출력 최적화
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);

	int N, L;
	std::cin >> N >> L;
	std::deque<std::pair<int, int>> dq; // {index, value}

	for (int i{}; i < N; ++i) {
		int now{};
		std::cin >> now;
		
        // 1. 윈도우 범위를 벗어난(오래된) 데이터 제거
		if (!dq.empty() && dq.front().first <= i - L) {
			dq.pop_front();
		}
		
        // 2. 현재 값보다 큰 이전 값들은 최솟값 후보에서 탈락 (Monotonic 유지)
		while (!dq.empty() && dq.back().second >= now) {
			dq.pop_back();
		}
		
        // 3. 현재 값 추가
		dq.push_back({ i,now });
		
        // 4. 최솟값(맨 앞) 출력
		std::cout << dq.front().second << ' ';
	}
}
```
# 04-5 스택과 큐
# [백준] 1874: 스택 수열

## 1. 문제 정보
- **태그**: #스택  #자료구조 #구현
- **난이도**: 실버 2
- **날짜**: 2025-12-24

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 1부터 N까지의 수를 스택에 넣었다(push) 빼면서(pop) 주어진 수열을 만들 수 있는지 확인하고, 가능하다면 연산 순서(+, -)를 출력한다.
- **핵심 발상**: 
    - 스택의 **LIFO(후입선출)** 특성을 이용해 시뮬레이션한다.
    - **오름차순**으로 숫자를 스택에 넣어야 하므로, 현재 넣어야 할 수(`now`)가 목표 수(`input`)보다 작거나 같다면 `input`이 될 때까지 계속 `push`한다.
    - 만약 `input`이 `now`보다 작다면, 이미 스택에 들어가 있다는 뜻이므로 `top`과 비교하여 바로 꺼낼 수 있는지 확인한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **스택 시뮬레이션**: `std::stack`을 사용하여 수열 생성 과정을 그대로 코드로 옮김.
- **실시간 처리 (On-the-fly)**: 입력 수열 전체를 벡터에 저장하지 않고, 입력을 받는 즉시 스택 연산을 수행하여 메모리를 절약함.
- **Fast I/O**: `std::ios::sync_with_stdio(false); cin.tie(NULL);`로 입출력 속도를 비약적으로 향상시킴.
- **시간 복잡도**: **O(N)**
    - 1부터 N까지의 각 숫자는 스택에 정확히 **한 번 push**되고 **한 번 pop**된다. 따라서 총 연산 횟수는 2N에 비례한다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **불가능한 경우 판단 (`NO`)**:
    - 스택의 `top`에 있는 값이 현재 만들어야 할 수열의 값(`input`)과 다르면, 그 수는 영원히 원하는 순서에 꺼낼 수 없으므로 불가능하다.
    - 이 경우 `NO`를 출력하고 **프로그램을 즉시 종료(`return 0;`)**해야 한다. 그렇지 않으면 뒤이어 불필요한 연산 결과가 출력될 수 있다.
- **메모리 초과 방지**:
    - 결과 출력을 위해 문자열을 계속 더하거나 벡터에 저장할 때 메모리 제한을 고려해야 하지만, 이 문제에서는 `vector<char>` 정도면 충분하다.
- **런타임 에러**:
    - `s.top()`이나 `s.pop()`을 호출하기 전에 스택이 비어있지 않은지(`!s.empty()`) 확인하는 습관이 중요하다. (단, 이 문제 로직상 `push`가 선행되므로 첫 진입 시 empty일 확률은 낮으나 방어적 코딩 권장)

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `result` 불리언 변수를 없애고 `return 0`으로 로직을 단순화한 점이 훌륭함.
    - `std::vector`에 미리 수열을 저장하지 않고 `cin >> input`으로 바로 처리하여 메모리 효율성을 높임.
    - `\n`을 사용하여 출력 버퍼 플러시로 인한 시간 초과를 방지함.

```cpp
#include <iostream>
#include <vector>
#include <stack>

int main() {
    // Fast I/O 설정
    std::ios::sync_with_stdio(false);
    std::cin.tie(NULL);

    int N{};
    std::cin >> N;
    
    std::vector<char> resultV;
    std::stack<int> s;
    int now{ 1 };

    for (int i{}; i < N; ++i) {
        int input{};
        std::cin >> input;

        if (input >= now) {
            // 목표값에 도달할 때까지 push
            while (input >= now) {
                s.push(now++);
                resultV.push_back('+');
            }
            s.pop();
            resultV.push_back('-');
        }
        else {
            // 이미 스택에 있는 경우, top과 일치하는지 확인
            int n{ s.top() };
            s.pop();
            if (n != input) {
                std::cout << "NO";
                return 0; // 불가능하면 즉시 종료
            }
            else {
                resultV.push_back('-');
            }
        }
    }

    // 결과 출력
    for (char c : resultV) {
        std::cout << c << '\n';
    }
}
```
# [백준] 17298: 오큰수

## 1. 문제 정보
- **태그**: #스택 #자료구조
- **난이도**: 골드 4
- **날짜**: 2025-12-24

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 수열의 각 원소에 대해, 자신의 오른쪽에 있는 수 중 가장 먼저 등장하는 큰 수(오큰수)를 구하라. (없으면 -1)
- **핵심 발상**: 
    - 이중 반복문($O(N^2)$)을 사용하면 $N=1,000,000$일 때 시간 초과가 발생한다.
    - **스택(Stack)**을 "아직 오큰수를 찾지 못한 수들의 대기소"로 활용해야 한다.
    - 스택에는 수의 **값**이 아닌 **인덱스(Index)**를 저장해야 나중에 정답 배열(`NGE`)을 갱신하기 편하다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **모노톤 스택 (Monotonic Stack)**:
    - 스택 안의 원소들이 오름차순 혹은 내림차순을 유지하도록 관리하는 기법.
    - 현재 수(`A[i]`)가 스택의 top이 가리키는 수(`A[s.top()]`)보다 크면, 스택 top의 오큰수는 바로 현재 수가 된다.
    - 이를 `while` 문으로 반복하여, 현재 수보다 작은 스택 안의 수들을 모두 정리(pop)한다.
- **시간 복잡도**: **O(N)**
    - 겉보기엔 이중 반복문처럼 보이지만, 모든 숫자는 스택에 딱 한 번 `push` 되고 최대 한 번 `pop` 된다.
    - 따라서 총 연산 횟수는 $2N$을 넘지 않는다.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **값 vs 인덱스**: 스택에 `A[i]`(값)를 넣으면, 나중에 그 값이 배열의 몇 번째 위치였는지 알 수 없어 정답을 채우기 어렵다. 반드시 **인덱스 `i`**를 넣자.
- **초기화**: 정답 배열(`NGE`)을 미리 `-1`로 초기화해두면, 오큰수가 없는 경우(스택에 끝까지 남아있는 경우)를 따로 처리할 필요가 없어 코드가 간결해진다.
- **출력 속도**: 출력이 많으므로 `std::endl` 대신 `\n`을 사용해야 시간 초과를 피할 수 있다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - 입력을 받음과 동시에 스택 로직을 처리하여 메모리와 시간을 효율적으로 사용했다.
    - `vector`를 `-1`로 초기화하여 불필요한 후처리를 없앤 점이 훌륭하다.
    - 변수명을 직관적으로 사용하여 가독성이 좋다.

```cpp
#include <iostream>
#include <vector>
#include <stack>

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);

	int N{};
	std::cin >> N;
	std::vector<int> A(N, 0);
	std::vector<int> NGE(N, -1); // 오큰수를 못 찾은 경우를 대비해 -1로 초기화
	std::stack<int> s;
	
	for (int i{}; i < N; ++i) {
		std::cin >> A[i];
		// 스택이 비어있지 않고, 현재 수가 스택 top이 가리키는 수보다 크다면
		// 스택 top의 오큰수는 현재 수(A[i])가 된다.
		while (!s.empty() && A[s.top()] < A[i]) {
			NGE[s.top()] = A[i];
			s.pop();
		}
		s.push(i); // 현재 인덱스를 스택에 넣어 다음 비교를 기다림
	}
	
	for (int i : NGE) {
		std::cout << i <<시 ' ';
	}
}
```
# [백준] 2164: 카드2

## 1. 문제 정보
- **태그**: #큐 #자료구조 #구현
- **난이도**: 실버 4
- **날짜**: 2025-12-24

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 1부터 N까지의 카드가 순서대로 놓였을 때, "제일 위 카드를 버리고, 그 다음 카드를 제일 아래로 옮기는" 과정을 반복하여 마지막에 남는 카드를 구하시오.
- **핵심 발상**: 
    - 문제에서 설명하는 동작(First In, First Out)이 **큐(Queue)** 자료구조의 특성과 정확히 일치함을 파악하는 것이 중요합니다.
    - 규칙성(2의 제곱수 관련)을 찾아 수학적으로 풀 수도 있지만, $N$의 범위가 500,000이므로 $O(N)$ 시뮬레이션으로도 충분히 통과 가능합니다. 

## 3. 알고리즘 & 구현 테크닉 🛠️
- **std::queue**: C++ STL의 `queue`를 사용하여 문제의 동작을 그대로 시뮬레이션했습니다.
    - `pop()`: 카드를 버리는 동작
    - `push(front())`: 카드를 맨 뒤로 옮기는 동작
- **시간 복잡도**: $O(N)$
    - 카드가 하나 버려질 때마다 큐의 크기가 1씩 줄어듭니다.
    - $N$장의 카드가 1장이 될 때까지 반복하므로 약 $N$번의 연산이 수행됩니다. ($N \le 500,000$ 이므로 시간 제한 2초 내에 충분함) 

## 4. 주의할 점 & 오답 포인트 ⚠️
- **자료구조 선택**: 
    - 만약 `std::vector`를 사용하여 `erase(begin())`을 수행하면, 앞쪽 요소를 삭제할 때마다 뒤의 요소들을 당겨와야 하므로 시간 복잡도가 $O(N^2)$이 되어 **시간 초과(Time Limit Exceeded)**가 발생합니다. 반드시 `queue`나 `deque`를 써야 합니다.
- **예외 처리 (N=1)**:
    - 입력이 1일 때 `while(q.size() > 1)` 루프에 진입하지 않고 바로 1을 출력해야 합니다. 작성하신 코드는 이 조건을 잘 처리하고 있습니다.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `std::ios::sync_with_stdio(false); cin.tie(NULL);`로 입출력 성능 최적화를 아주 잘 해주셨습니다.
    - `int N{}`와 같은 유니폼 초기화(Uniform Initialization) 사용도 모던 C++ 스타일로 좋습니다.
    - **로직 피드백**: 작성하신 `pop` -> `push` -> `pop` 순서는 논리적으로 완벽하게 작동합니다. 다만, 보통 가독성을 위해 아래와 같이 작성하기도 하니 참고만 해주세요!
      ```cpp
      q.pop(); // 맨 앞 버림
      int temp = q.front(); // 그 다음 카드를 저장
      q.pop(); // 앞에서 뺌
      q.push(temp); // 뒤로 넣음
      ```
      (작성하신 코드는 `temp` 변수 없이 바로 `push(q.front())` 후 `pop`을 하여 더 간결합니다 👍)

```cpp
#include <iostream>
#include <queue>

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);

	std::queue<int> q;
	int N{};
	std::cin >> N;

	for (int i{1}; i <= N; ++i) {
		q.push(i);
	}
	while (q.size() > 1){
		q.pop();             // 1. 제일 위 카드 버림
		q.push(q.front());   // 2. 그 다음 카드를 제일 아래로 복사
		q.pop();             // 3. 복사된 원본(앞쪽) 제거
	}
	std::cout << q.front();
}
```
# [백준] 11286: 절댓값 힙

## 1. 문제 정보
- **태그**: #자료구조 #우선순위_큐 #힙 #커스텀_정렬
- **난이도**: 실버 I
- **날짜**: 2025-12-28

## 2. 문제 요약 & 핵심 아이디어 💡
- **문제 목표**: 배열에 정수를 삽입하고, 0이 입력될 때마다 **절댓값이 가장 작은 값**을 출력하고 제거한다. (절댓값이 같다면 가장 작은 수를 우선 출력)
- **핵심 발상**: 
    - 일반적인 큐나 스택으로는 $O(N)$이 걸리므로 시간 초과 발생. $O(\log N)$으로 삽입/삭제가 가능한 **우선순위 큐(Priority Queue)**를 사용해야 한다.
    - 기본 `priority_queue`는 내림차순(Max Heap)이므로, 문제 조건에 맞는 **커스텀 비교 구조체(Functor)**를 만들어야 한다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **자료구조**: `std::priority_queue` (Heap)
- **커스텀 비교 연산자 (`struct compare`)**:
    - C++의 `priority_queue` 비교 함수는 `true`를 반환할 때 **우선순위가 낮다고 판단(뒤로 보냄)**한다.
    - **조건 1**: 절댓값이 다르면? $\to$ 절댓값이 큰 쪽이 뒤로 가야 함 (`abs(a) > abs(b)`)
    - **조건 2**: 절댓값이 같으면? $\to$ 실제 값이 큰 쪽(양수)이 뒤로 가야 함 (`a > b`)
- **시간 복잡도**: $O(N \log N)$
    - $N$개의 연산에 대해 힙의 삽입/삭제는 트리의 높이만큼인 $\log N$ 시간이 소요됨.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **비교 연산자 헷갈림 주의**: `std::sort`의 비교 함수와 반대 개념이다. `priority_queue`에서는 `a`가 `b`보다 "나중(아래)"에 와야 할 때 `true`를 반환해야 한다.
- **Empty Check**: 큐가 비어있는데 `pop()`이나 `top()`을 호출하면 런타임 에러가 발생하므로, 0이 입력되었을 때 `empty()` 확인이 필수다.
- **시간 초과(TLE)**: 입출력이 많으므로 `ios::sync_with_stdio(false); cin.tie(NULL);`은 필수.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `struct`를 활용해 비교 로직을 깔끔하게 분리한 점이 아주 좋습니다.
    - `int x{}`와 같은 유니폼 초기화(Uniform Initialization) 문법을 사용하여 변수 초기화 실수를 방지한 점이 인상적입니다.
    - 엣지 케이스(큐가 비었을 때 0 출력) 처리도 완벽합니다.

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <cmath>

// 커스텀 정렬 기준 정의
struct compare {
	bool operator()(int a, int b) {
		// 1. 절댓값이 다르면, 절댓값이 작은 것이 우선(큰 것이 뒤로 감 -> true)
		if (abs(a) != abs(b)) {
			return abs(a) > abs(b);
		}
		// 2. 절댓값이 같다면, 실제 값이 작은 것이 우선(큰 것이 뒤로 감 -> true)
		return a > b;
	}
};

int main() {
	// 입출력 속도 최적화
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);

	int N{};
	std::cin >> N;
	
	// 커스텀 비교 구조체 적용
	std::priority_queue<int, std::vector<int>, compare> pq;
	
	for (int i{}; i < N; ++i) {
		int x{};
		std::cin >> x;
		if (x == 0) {
			if (pq.empty())
				std::cout << 0 << '\n';
			else {
				std::cout << pq.top() << '\n';
				pq.pop();
			}
		}
		else pq.push(x);
	}
}
```
