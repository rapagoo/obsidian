# 05-1 버블 정렬
# [백준] 1377: 버블 소트

## 1. 문제 정보
- **태그**: #정렬
- **난이도**: 골드 2
- **날짜**: 2025-12-28

## 2. 문제 요약 & 핵심 아이디어 💡
- **문제 요약**: 버블 정렬 알고리즘에서 바깥쪽 루프(Pass)가 몇 번 실행된 후 정렬이 완료되는지 출력하는 문제.
- **핵심 발상**: 
    - 실제 버블 정렬($O(N^2)$)을 수행하면 시간 초과가 발생함.
    - 버블 정렬의 특성상 **큰 수는 오른쪽으로 빠르게 이동**하지만, **작은 수는 왼쪽으로 한 단계(Pass) 당 최대 1칸만 이동**할 수 있음을 이용.
    - 즉, 어떤 숫자가 **왼쪽으로 가장 많이 이동한 거리**가 곧 정렬에 필요한 최소 단계 수가 됨.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **정렬 (Sorting)**: `std::pair`를 사용해 `(값, 원래 인덱스)`를 저장한 뒤 값을 기준으로 오름차순 정렬함.
- **시간 복잡도**: $O(N \log N)$
    - `std::sort`를 사용하는 정렬 시간이 지배적이며, 이후 루프는 $O(N)$이므로 전체 시간 복잡도는 $O(N \log N)$으로 제한 시간(2초) 내에 충분히 통과 가능.

## 4. 주의할 점 & 오답 포인트 ⚠️
- **문제의 종료 조건**: 문제에서 제시된 코드는 정렬이 완료된 직후 바로 끝나는 것이 아니라, **더 이상 교환(swap)이 일어나지 않음을 확인하는 루프**가 한 번 더 실행됨.
- **최종 정답**: 따라서 `max(원래 인덱스 - 현재 인덱스)` 값에 반드시 **+1**을 해주어야 함.
- **안정 정렬(Stable Sort)**: 값이 같을 때 원래 순서가 섞이면 인덱스 계산에 오차가 생길 수 있음. `std::sort`와 `pair`를 함께 쓰면 `first`가 같을 때 `second`(인덱스)로 비교하므로 자연스럽게 안정 정렬 효과를 얻음.

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - `std::pair`를 활용해 값과 인덱스를 묶어서 처리한 점이 아주 깔끔함.
    - `std::ios::sync_with_stdio(false);`와 `std::cin.tie(NULL);`로 입출력 성능을 최적화하여 대량의 데이터($N \le 500,000$) 처리에 대비한 점이 훌륭함.
    - 불필요한 변수 없이 핵심 로직만 간결하게 작성됨.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);

	int N;
	std::cin >> N;
	std::vector<std::pair<int, int>> A(N);

	for (int i{}; i < N; ++i) {
		std::cin >> A[i].first;
		A[i].second = i; // 원래 인덱스 저장
	}

	std::sort(A.begin(), A.end()); // 값 기준 정렬 (값이 같으면 인덱스 순)
	int max{};

	for (int i{}; i < N; ++i) {
		// (원래 인덱스 - 현재 인덱스)가 가장 큰 값 찾기
		if (A[i].second - i > max) {
			max = A[i].second - i;
		}
	}
	// 마지막 확인 루프 포함 +1
	std::cout << max + 1;
}
```
# 05-2 선택 정렬
# [백준] 1427: 소트인사이드

## 1. 문제 정보
- **태그**: #정렬 #문자열 #구현
- **난이도**: 실버 5
- **날짜**: 2025-12-31

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: 주어진 숫자의 각 자릿수를 내림차순(큰 수 $\rightarrow$ 작은 수)으로 정렬하여 출력하는 것.
- **핵심 발상**: 
  - 숫자를 정수형(`int`)으로 받아 자릿수 계산(`% 10`)을 하는 대신, **문자열(`std::string`)**로 입력받으면 마치 배열처럼 각 자릿수에 바로 접근할 수 있음.
  - 문자열 내부의 문자(`char`)끼리 비교해도 아스키 코드 값에 의해 숫자의 크기 비교와 동일한 결과가 나옴.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **선택 정렬 (Selection Sort)**: 
  - 배열의 앞에서부터 차례대로 남은 구간 중 **가장 큰 값(내림차순)**을 찾아 현재 위치(`i`)와 교환(`swap`)하는 방식을 사용.
  - 이 문제에서는 $N$이 최대 10(1,000,000,000)으로 매우 작기 때문에 $O(N^2)$ 알고리즘으로도 충분히 통과 가능.
- **시간 복잡도**: $O(N^2)$
  - 이중 `for` 문을 사용했기 때문에 자릿수 길이의 제곱만큼 연산이 수행됨. 
  - (참고: `std::sort` 사용 시 $O(N \log N)$)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **Signed/Unsigned Mismatch**:
  - `s.length()`는 `size_t` (부호 없는 정수)를 반환하는 반면, 루프 변수 `i`와 `j`는 `int` (부호 있는 정수)로 선언됨.
  - 컴파일 경고가 발생할 수 있으므로, 루프 변수의 타입을 `size_t`로 하거나 `auto`를 사용하는 것이 더 안전함.
- **정렬 방향**:
  - 내림차순이므로 최댓값을 찾아야 함. 조건문이 `s[j] > s[max_idx]`인지 꼭 확인할 것. (반대면 오름차순이 됨)

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
  - **장점**: `int i{}`, `int max_idx{ i }` 등 C++11 이상의 **유니폼 초기화(Uniform Initialization)**를 사용하여 코드가 현대적이고 깔끔함.
  - **구현**: 선택 정렬의 로직(최댓값 탐색 $\rightarrow$ `std::swap`)을 정석대로 잘 구현했음.
  - **개선 팁**: `int` 대신 `size_t`를 사용하면 형 변환 경고를 없앨 수 있음.

```cpp
#include <iostream>
#include <string>

int main() {
	std::string s;
	std::cin >> s;
    
	// i는 size_t 혹은 unsigned int로 선언하는 것이 더 안전함
	for (int i{}; i < s.length() - 1; ++i) {
		int max_idx{ i };
		for (int j{ i + 1 }; j < s.length(); ++j) {
			// 내림차순이므로 더 큰 값을 찾음
			if (s[j] > s[max_idx]) {
				max_idx = j;
			}
		}
		std::swap(s[i], s[max_idx]);
	}
	std::cout << s;
}
```
# 05-3 삽입 정렬
# [백준] 11399: ATM

## 1. 문제 정보
- **태그**: #그리디 #정렬 #구현
- **난이도**: Silver IV
- **날짜**: 2025-12-31

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: $N$명의 사람이 ATM을 이용할 때, 각 사람이 돈을 인출하는 데 걸리는 시간의 합(대기 시간 + 인출 시간)의 **최솟값** 구하기.
- **핵심 발상**: 
    - 기다리는 시간이 뒷사람에게 계속 누적되므로, **인출 시간이 짧은 사람**이 먼저 서야 전체 대기 시간이 줄어든다. (그리디 알고리즘)
    - 오름차순으로 정렬했을 때, $i$번째 사람은 총 $(N-i)$번만큼 뒷사람들의 대기 시간에 영향을 준다.

## 3. 알고리즘 & 구현 테크닉 🛠️
- **삽입 정렬 (Insertion Sort)**: `std::sort` 대신 직접 정렬 로직을 구현. 
    - 이미 정렬된 앞부분 배열에 현재 값(`key`)이 들어갈 위치를 찾아 삽입하는 방식.
- **수학적 접근**: 이중 반복문으로 누적합을 구하는 대신, $P[i] \times (N-i)$ 공식을 사용하여 $O(N)$의 반복문 하나로 최종 결과 계산.
- **시간 복잡도**: $O(N^2)$ 
    - 삽입 정렬의 최악 시간 복잡도가 $O(N^2)$이기 때문. ($N \le 1,000$이므로 통과 가능)

## 4. 주의할 점 & 오답 포인트 ⚠️
- **삽입 정렬의 대입 위치**: `while` 루프 안에서는 값들을 뒤로 밀기만 하고(`A[j+1] = A[j]`), 루프가 끝난 뒤에 비로소 `key` 값을 삽입(`A[j+1] = key`)해야 함.
- **자료형 범위**: $N$과 $P_i$가 최대 1,000일 때, 정답의 최댓값은 약 5억 정도이므로 `int`로 충분함. (약 21억까지 커버 가능)

## 5. 내 코드 & 피드백
- **코드 리뷰**: 
    - 입출력 최적화(`ios::sync_with_stdio`, `cin.tie`)를 잘 적용함.
    - 정렬 라이브러리에 의존하지 않고 직접 삽입 정렬을 구현하여 알고리즘 이해도를 높임.
    - 불필요한 메모리 사용 없이 깔끔하게 구현됨.
    - **Tip**: $N$이 10만 이상으로 커지면 삽입 정렬($O(N^2)$)은 시간 초과가 날 수 있으므로, 실전 코딩 테스트에서는 `std::sort`($O(N \log N)$)를 사용하는 것이 안전함.

```cpp
#include <iostream>
#include <vector>

int main() {
	// 입출력 속도 향상
	std::ios::sync_with_stdio(false);
	std::cin.tie(NULL);

	int N{};
	std::cin >> N;
	std::vector<int> A(N, 0);

	// 입력
	for (int i{}; i < N; ++i) {
		std::cin >> A[i];
	}

	// 삽입 정렬 (Insertion Sort) 구현
	for (int i{ 1 }; i < N; ++i) {
		int j{ i - 1 };
		int key{ A[i] };
		// key보다 큰 값들은 뒤로 한 칸씩 밀기
		while (j >= 0 && A[j] > key) {
			A[j + 1] = A[j];
			j--;
		}
		// 적절한 위치에 key 삽입
		A[j + 1] = key;
	}

	// 결과 계산: 각 시간이 더해지는 횟수(N-i)를 곱함
	int result{};
	for (int i{}; i < N; ++i) {
		result += A[i] * (N - i);
	}
	std::cout << result;
}
```
# 05-4 퀵 정렬
# [백준] 11004: K번째 수

## 1. 문제 정보
- **태그**: #정렬 #분할정복 #QuickSelect
- **난이도**: Silver V
- **날짜**: 2026-01-07

## 2. 문제 요약 & 핵심 아이디어 💡
- **목표**: N개의 수를 오름차순 정렬했을 때, 앞에서부터 K번째에 있는 수를 구하는 것.
- **핵심 발상**: **"전체를 다 정렬할 필요가 없다!"**
    - 퀵 정렬(Quick Sort)의 파티션(Partition) 과정을 수행한 후, 피벗(Pivot)이 놓인 위치가 바로 그 수의 **최종 정렬 위치**라는 점을 이용합니다.
    - 피벗의 위치와 K를 비교하여, K가 포함된 **한쪽 영역만** 재귀적으로 탐색합니다 (Quick Select).

## 3. 알고리즘 & 구현 테크닉 🛠️
- **Quick Select (퀵 선택)**: 
    - 퀵 정렬은 피벗 기준 좌우를 모두 재귀 호출하지만, 퀵 선택은 **`if (K < pivot)`** 조건을 통해 필요한 절반만 호출합니다.
    - 이를 통해 불필요한 연산을 획기적으로 줄입니다.
- **시간 복잡도**: **평균 O(N)**
    - 전체 정렬 시 $O(N \log N)$이지만, 탐색 범위를 절반씩 줄여나가므로 $N + N/2 + N/4 + ... = 2N$에 수렴하여 선형 시간에 해결 가능합니다.
    - *단, 최악의 경우(이미 정렬된 배열에서 피벗을 잘못 잡을 시) $O(N^2)$이 될 수 있어 피벗 설정이 중요함.*

## 4. 주의할 점 & 오답 포인트 ⚠️
- **배열 범위 초과 (Out of Bounds)**: `while` 문 안에서 `i`와 `j`를 이동시킬 때, 반드시 경계 조건을 검사해야 함.
    - `i <= end`: 피벗보다 큰 수를 찾지 못해 끝까지 가는 경우 방지.
    - `j >= start + 1`: 피벗보다 작은 수를 찾지 못해 피벗(start) 위치까지 침범하는 경우 방지.
    - *이 부분이 누락되면 런타임 에러나 세그먼트 폴트 발생.*
- **피벗 교체 대상**: 파티션 종료 후 `swap(A[start], A[j])`를 하는 이유.
    - 반복문이 끝나면 `j`는 피벗보다 **작거나 같은 값**들의 경계(가장 오른쪽)에 위치함. 따라서 `j`와 바꿔야 피벗 왼쪽에 작은 값들이 오게 됨. (`i`와 바꾸면 큰 값이 앞으로 오게 되어 정렬이 깨짐)
- **입출력 속도**: 데이터가 500만 개(`5,000,000`)이므로 `ios_base::sync_with_stdio(false); cin.tie(NULL);` 필수.

## 5. 내 코드 & 피드백
- **코드 리뷰**:
    - **장점**: `mid`를 구해 피벗으로 설정(`swap(A[start], A[mid])`)한 점이 훌륭함. 이는 이미 정렬된 데이터가 들어올 때 $O(N^2)$으로 성능이 저하되는 것을 막아주는 좋은 테크닉임.
    - **피드백**: `partition` 함수 내의 `while` 루프 조건들이 처음엔 이해하기 어렵지만, "메모리 안전 펜스" 역할을 한다는 것을 기억하고 패턴처럼 익혀두면 좋음.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 데이터를 분할하고 피벗의 최종 위치를 반환하는 함수
int partition(vector<int>& A, int start, int end) {
    // 1단계: 중앙값을 피벗으로 설정하고 맨 앞과 swap
    // (이미 정렬된 배열 등 최악의 경우를 피하기 위한 전략)
    int mid = (start + end) / 2;
    swap(A[start], A[mid]);
    int pivot = A[start];

    int i = start + 1;
    int j = end;

    // 2단계: i, j 포인터를 이동하며 데이터 분할
    while (i <= j) {
        // 경계 조건(i <= end) 필수! 피벗보다 큰 수 찾기
        while (i <= end && A[i] < pivot) i++; 
        // 경계 조건(j >= start + 1) 필수! 피벗보다 작은 수 찾기
        while (j >= start + 1 && A[j] > pivot) j--; 

        if (i <= j) {
            swap(A[i++], A[j--]); // 잘못된 위치의 두 수 교체
        }
    }

    // 3단계: 피벗을 제자리(j)로 옮기기
    // j는 피벗보다 '작거나 같은' 영역의 끝이므로 j와 바꿔야 함
    swap(A[start], A[j]);
    return j;
}

// K번째 수를 찾기 위해 영역을 좁혀가는 함수
void quickSelect(vector<int>& A, int start, int end, int K) {
    if (start >= end) return;

    int pivot_idx = partition(A, start, end);

    if (pivot_idx == K) {
        return; // K번째 인덱스를 찾았으므로 종료
    } else if (K < pivot_idx) {
        quickSelect(A, start, pivot_idx - 1, K); // 왼쪽 영역 탐색
    } else {
        quickSelect(A, pivot_idx + 1, end, K); // 오른쪽 영역 탐색
    }
}

int main() {
    // 입출력 속도 향상 (500만 개 데이터 처리 필수)
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N, K;
    cin >> N >> K;

    vector<int> A(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }

    // 문제의 K번째는 1부터 시작하므로 인덱스(0부터 시작)에 맞춰 K-1 전달
    quickSelect(A, 0, N - 1, K - 1);

    cout << A[K - 1];

    return 0;
}
```

